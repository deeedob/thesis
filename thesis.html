<h1 id="chapter-1-introduction">Chapter 1: Introduction</h1>
<h2 id="motivation">1.1 Motivation</h2>
<p>Throughout this work, we will discuss plugins and their impact on the
usability of an application. Specifically, we will focus on the
development of graphical user interfaces (GUIs) for audio plugins,
examining their influence on user experiences and their relationship
with development workflow. When considering GUIs broadly, it’s natural
to contemplate their flexibility and stability. The sheer number of
operating systems, graphic backends, and platform-specific details is
more than any single developer could realistically address.</p>
<p>Investing time in learning and potentially mastering a skill
naturally leads to the desire to apply it across various use-cases.
Opting for a library that has <em>withstood the test of time</em>
enhances stability, yet professionals often seek continuity, preferring
not to re-acquaint themselves with a subject solely due to the
limitations of their chosen toolkit for the next project.</p>
<p>Therefore, Qt, a cross-platform framework for crafting GUIs, comes to
mind when considering the development of an audio plugin UI<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> intended for widespread platform
compatibility. The expertise gained from utilizing the Qt framework is
versatile, suitable for crafting mobile, desktop, or even embedded
applications without relearning syntax or structure. As one of Qt’s
mottos aptly states:</p>
<blockquote>
<p>Code once, deploy everywhere.</p>
</blockquote>
<p>The significance of this subject becomes evident when browsing the
forum “kvraudio.com”, a renowned platform for audio-related
discussions.</p>
<p>A brief search of:
<code>"Qt" "Plugin" :site www.kvraudio.com</code></p>
<p>uncovers <em>57’800</em> results, with <em>580</em> from the span
between <em>10/19/2022</em> and <em>10/19/2023</em>. While the weight of
such figures may be debated, they certainly suggest the relevance and
potential of Qt as a feasible option for audio plugin development.</p>
<h2 id="objective">1.2 Objective</h2>
<p>A primary challenge in integrating Qt user interfaces within audio
plugin environments centers on reentrancy. A program or function is
considered re-entrant if it can safely support concurrent invocations,
meaning it can be “re-entered” within the same process. Such behavior is
vital as audio plugins often instantiate multiple times from within
itself. To illustrate this challenge, consider the following
example:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// reentrancy.cpp</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> nonReentrantFunction<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Non-Reentrant: &quot;</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">static</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reentrantFunction<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Reentrant: &quot;</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;First call:&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    nonReentrantFunction<span class="op">();</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    reentrantFunction<span class="op">();</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">Second call:&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    nonReentrantFunction<span class="op">();</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    reentrantFunction<span class="op">();</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In C++, static objects and variables adhere to the <a
href="https://en.cppreference.com/w/c/language/static_storage_duration">static
storage duration</a>:</p>
<blockquote>
<p>The storage for the object is allocated when the program starts and
deallocated when it concludes. Only a single instance of the object
exists.</p>
</blockquote>
<p>The problem here is the single instance of the object per application
process. This necessitates caution when working with static types where
reentrancy is essential. When the above program is executed, the outcome
is:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compile and run the program</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">g++</span> <span class="at">-o</span> build/reentrancy reentrancy.cpp <span class="at">-Wall</span> <span class="at">-Wextra</span> <span class="at">-pedantic-errors</span> <span class="dt">\</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">;</span><span class="ex">./build/reentrancy</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">First</span> call:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Non-Reentrant:</span> 0 1 2</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Reentrant:</span> 0 1 2</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ex">Second</span> call:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="ex">Non-Reentrant:</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="ex">Reentrant:</span> 0 1 2</span></code></pre></div>
<p>While the initial invocation of both functions is successful,
re-entering the function during the second call results in no output
from the non-reentrant function. This outcome stems from the use of the
static specifier in the for loop counter. Due to this, the counter
doesn’t reset between calls, failing to meet the <code>i &lt; 3</code>
condition in subsequent invocations, as it retains its initialized value
from the first call.</p>
<p>Static objects offer global accessibility and can enhance application
design by allowing for the initialization of crucial objects just once,
with the capability to share them throughout the entire codebase.
However, this approach has its trade-offs, especially in terms of
integration and operation in multi-threaded environments. This is
evident in the case of QApplication variants like QCoreApplication and
QGuiApplication. These classes, which manage Qt’s event loop through
<code>Q*Application::exec()</code>, are static:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// qtbase/src/corelib/kernel/qcoreapplication.h</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> <span class="ex">QCoreApplication</span> <span class="op">*</span>instance<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> self<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>This design choice means only one QApplication can exist within a
process. Issues arise when a plugin-loading-host, as <a
href="https://github.com/rncbc/qtractor/blob/0e987e6c41796a4cbe85e499ae890b5989be8b82/src/qtractor.h#L60">QTractor</a>,
already utilizes a QApplication object or when multiple plugin instances
operate within a single process. At first glance, one might assume the
ability to verify the presence of a QApplication within the process and
then conveniently reuse its event loop:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span><span class="ex">qGuiApp</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="dt">int</span> argc <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="at">static</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span><span class="st">&quot;&quot;</span><span class="op">)</span> <span class="op">};</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="ex">QGuiApplication</span><span class="op">(</span>argc<span class="op">,</span> argv<span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Set our &#39;QWindow *window&#39; to the received window from the host.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>window<span class="op">-&gt;</span>setParent<span class="op">(</span><span class="ex">QWindow::fromWinId</span><span class="op">(</span>WId<span class="op">(</span>hostWindow<span class="op">)));</span></span></code></pre></div>
<p>Attempting to reuse the event system of a parent window, while
occasionally effective, is fraught with uncertainties. A primary
limitation is that this approach is not consistently supported across
different platforms. For instance on Linux, where event systems such as
<strong>xcb</strong> and <strong>glib</strong> are not standardized
would render this method impractical. Additionally, there are risks
associated with connecting to an event loop from an outdated version,
which could lead to compatibility issues and impaired functionality.</p>
<p>Another concern is the management of multiple instances attempting to
connect to the same event loop, raising doubts about the reliability and
efficiency. Consequently, this approach is not a dependable solution for
the challenges faced in integrating Qt user interfaces with audio plugin
environments.</p>
<p>This research is focused on developing innovative methods to
integrate Qt-based graphical user interfaces seamlessly into the audio
plugin landscape. The main objective is to provide seamless integration
with audio plugin standards, ensuring effective and responsible
communication. A crucial aspect of this integration is to enhance user
experience by providing a stable method that works across all major
operating systems. An important part of achieving this is the seamless
integration of events generated by the plugin into Qt’s event system.
This strategy is designed to offer a development process that is
inherently aligned with Qt’s principles, making it more intuitive for
developers and ensuring a robust, platform-independent solution.</p>
<p>The research primarily focuses on the CLAP plugin standard. CLAP is
chosen for its innovative capabilities and its relevance in the context
of current technology trends. This standard is viewed as the most
suitable for the intended integration tasks. The usage of CLAP
emphasizes the study’s aim to tackle the intricate challenges of
integrating Qt’s comprehensive GUI framework with the dynamic field of
audio plugins.</p>
<h2 id="structure">1.3 Structure</h2>
<p>TODO: Structure</p>
<h1 id="chapter-2-foundation">Chapter 2: Foundation</h1>
<h2 id="plugins">2.1 Plugins</h2>
<p><strong>Plug</strong>-<strong><em>ins</em></strong>, at their
essence, serve as dynamic extensions, enhancing the capabilities of a
plugin-loading host. One can perceive them as <em>on-demand</em>
features ready for deployment. Their prevalence is evident across both
the software and hardware domains. For instance, they can be specialized
filters added to image processing applications like <em>Adobe
Photoshop</em>, dynamic driver modules integrated into operating systems
such as <em>GNU/Linux</em> <span class="citation"
data-cites="cppn2074">[6]</span>, or system-specific extensions found in
frameworks like <em>Qt</em>.</p>
<figure id="fig:plugarch">
<img src="./images/plugin-basic.png" alt="basic plugin architecture" />
<figcaption>Figure 1: basic plugin architecture</figcaption>
</figure>
<p><em>fig. 1</em> offers a visual representation of this mechanism. On
the left, we have the host, which is equipped with the capability to
accommodate the plugin interface. Centrally located is the plugin
interface itself, serving as the communication bridge between the host
and the plugin. The right side correlates with the actual implementation
of the plugin. Once the plugin is successfully loaded by the host, it
actively <em>requests</em> the necessary functionalities from the plugin
as and when required. This interaction entails invoking specific
functions and subsequently taking actions based on their results. While
plugins can, on occasion, prompt functions from the host, their primary
role is to respond to the host’s requests. The foundation of this
interaction is the meticulously designed plugin interface that
facilitates this bilateral communication.</p>
<p>A practical illustration of such an interface is seen in the
<strong>CL</strong>ever <strong>A</strong>udio <strong>P</strong>lugin
(CLAP) format. This standard establishes the communication protocols
between a Digital Audio Workstation (DAW) and its various plugins, be it
synthesizers, audio effects, or other elements. A segment from the C-API
reads:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Call start processing before processing.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>   <span class="co">// [audio-thread &amp; active_state &amp; !processing_state]</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">bool</span><span class="op">(</span>CLAP_ABI <span class="op">*</span>start_processing<span class="op">)(</span><span class="at">const</span> <span class="kw">struct</span> clap_plugin <span class="op">*</span>plugin<span class="op">);</span></span></code></pre></div>
<p>To unpack this, the function outlines the calling convention for a
function pointer named <code>start_processing</code>. This function
returns a <code>bool</code> and receives a constant pointer to the
struct <code>clap_plugin</code> as an argument. The preprocessor macro
<code>CLAP_ABI</code> is an implementation detail without significant
importance. In a practical scenario, a plugin can assign a specific
function to this pointer. This allows the plugin to respond to calls
made by the host, which controls the timing of these calls</p>
<h3 id="shared-libraries-and-plugins">2.1.1 Shared Libraries and
Plugins</h3>
<p>When discussing plugins written in a compiled language, we typically
refer to them as shared libraries. A shared library, also known as a
dynamic library or DSO<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>, is a reusable object that exports a
table of symbols (e.g., functions, variables, global data). These
libraries are loaded into shared memory once and made accessible to all
instances that might utilize them. This approach ensures efficient
memory and resource management. Commonly used libraries can greatly
benefit from this. However, this efficiency can compromise portability,
as these libraries must either be present on the target platform or
packaged with the application.</p>
<p>A canonical example is the <em>standard C library</em> (libc). Given
its presence in nearly every application, the efficiency of shared
libraries becomes evident.</p>
<p>To demonstrate, we’ll examine the shared object dependencies of some
standard applications using the Linux utility <strong>ldd</strong>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ldd</span> /usr/bin/git</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">linux-vdso.so.1</span> <span class="er">(</span><span class="ex">0x00007ffcf7b98000</span><span class="kw">)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">libpcre2-8.so.0</span> =<span class="op">&gt;</span> /usr/lib/libpcre2-8.so.0 <span class="er">(</span><span class="ex">0x00007f5c0f286000</span><span class="kw">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">libz.so.1</span> =<span class="op">&gt;</span> /usr/lib/libz.so.1 <span class="er">(</span><span class="ex">0x00007f5c0f26c000</span><span class="kw">)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="ex">libc.so.6</span> =<span class="op">&gt;</span> /usr/lib/libc.so.6 <span class="er">(</span><span class="ex">0x00007f5c0ec1e000</span><span class="kw">)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="fu">ldd</span> /usr/bin/gcc</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">linux-vdso.so.1</span> <span class="er">(</span><span class="ex">0x00007ffef8dfd000</span><span class="kw">)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="ex">libc.so.6</span> =<span class="op">&gt;</span> /usr/lib/libc.so.6 <span class="er">(</span><span class="ex">0x00007fcf68af9000</span><span class="kw">)</span></span></code></pre></div>
<p>Shared libraries can be further categorized into:</p>
<ul>
<li><em>Dynamically linked libraries</em> - The library is linked
against the application after the compilation. The kernel then loads the
library, if not already in shared memory, automatically upon
execution.</li>
<li><em>Dynamically loaded libraries</em> - The application takes full
control by loading the DSO manually with libraries like <a
href="https://linux.die.net/man/3/dlopen">dlopen</a> or <a
href="https://doc.qt.io/qt-6/qlibrary.html">QLibrary</a>.</li>
</ul>
<p>In the context of audio plugins, the approach of dynamically loaded
libraries is commonly used for loading plugin instances. Unlike
dynamically linked libraries, where the kernel handles the loading
post-compilation, dynamically loaded libraries give the application the
autonomy to load the Dynamic Shared Object (DSO) manually. Considering
the foundational role of shared libraries in every plugin, it’s
beneficial to delve deeper into their intricacies. Let’s explore a basic
example:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// simplelib.cpp</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string_view&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;source_location&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef _WIN32</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#   define EXPORT </span><span class="ex">__declspec(dllexport)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#   define EXPORT </span><span class="ex">__attribute__((visibility(</span><span class="st">&quot;default&quot;</span><span class="ex">)))</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> EXPORT <span class="dt">void</span> lib_hello<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>string_view<span class="op"> </span>LibName <span class="op">=</span> <span class="st">&quot;simplelib&quot;</span><span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;</span><span class="sc">{}</span><span class="st">: called from </span><span class="sc">{}</span><span class="st">:</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> LibName<span class="op">,</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>source_location<span class="bu">::</span>current<span class="op">().</span>file_name<span class="op">(),</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>source_location<span class="bu">::</span>current<span class="op">().</span>line<span class="op">()</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code defines a minimal shared library. After including the
required standard-headers, we define a compile time directive that is
used to signal the visibillity of the exported symbols. Windows and Unix
based system differ here. On Windows with MSVC the symbols are
<em>not</em> exported by default, and require explicit marking with
<code>__declspec(dllexport)</code>. On Unix based system we use the
visibillity attribute. Since by default all symbols are exported on
these platforms, rendering this attribute seemingly redundant, it
remains advantageous to maintain clarity. This would also allows us to
control the visibillity in the linking step by simply using the linker
flag <code>-fvisibility=hidden</code> to hide all symbols. You might
noticed the absence of <code>__declspec(dllimport)</code> here. We
actually don’t need it in this example because we’re going to load the
library manually, like a plugin.</p>
<p>The function <code>void lib_hello()</code> is additionally marked
with <code>extern "C"</code> to provide C linkage, which makes this
function also available to clients loading this library from C-code. The
function then simply prints the name and the source location of the
current file.</p>
<p>Now lets have a look at the host, which is loading the shared library
during its runtime. The implementation is Unix specific but would follow
similar logic on Windows as well:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// simplehost.cpp</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;dlfcn.h&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load the shared library.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> handle <span class="op">=</span> dlopen<span class="op">(</span><span class="st">&quot;./libsimplelib.so&quot;</span><span class="op">,</span> RTLD_LAZY<span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>handle<span class="op">)</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> EXIT_FAILURE<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Resolve the exported symbol.</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">*</span>hello <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">void</span> <span class="op">(*)()&gt;(</span>dlsym<span class="op">(</span>handle<span class="op">,</span> <span class="st">&quot;lib_hello&quot;</span><span class="op">));</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>hello<span class="op">)</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> EXIT_FAILURE<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Call the function.</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    hello<span class="op">();</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Unload the shared library.</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    dlclose<span class="op">(</span>handle<span class="op">);</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> EXIT_SUCCESS<span class="op">;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For simplicity reasons the error handling has been kept to a minimum.
The code seen above is basically all it takes to <em>dynamically load
libraries</em>, and is what plugin-hosts are doing to interact with the
plugin interface.</p>
<p>To finalize this example, lets write a minimal build script and run
our <code>simplehost</code> executable.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"></code></pre></div>
<p>And finally run our script:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./build_and_run</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ex">simplelib:</span> called from simplelib.cpp:18</span></code></pre></div>
<p>Throughout our discussions, we’ll frequently reference the terms
<em>ABI</em> and <em>API</em>. To ensure clarity, let’s demystify these
terms. The <strong>API</strong>, an acronym for
<strong>A</strong>pplication <strong>P</strong>rogramming
<strong>I</strong>nterface, serves as a blueprint that dictates how
different software components should interact. Essentially, it acts as
an agreement, ensuring that software pieces work harmoniously together.
If we think of software as a puzzle, the API helps ensure that the
pieces fit together. On the flip side, we have the <strong>ABI</strong>
or <strong>A</strong>pplication <strong>B</strong>inary
<strong>I</strong>nterface, which corresponds to the actual binary that
gets executed.</p>
<p>In software development, as we move from version 1.1 to 1.2, then to
1.3, and so on, keeping a consistent interface is crucial. This is where
<strong><em>Binary Compatibility</em></strong> comes into play. It’s
essential for ensuring that various versions of software libraries can
work together smoothly. Ideally, software built with version 1.1 of an
interface should seamlessly operate with version 1.3, without
recompilation or other adjustments.</p>
<p>Take this example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Version 1.0 of &#39;my_library&#39;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">uint32_t</span> MyType<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_library_api<span class="op">(</span>MyType type<span class="op">);</span></span></code></pre></div>
<p>Here, <code>MyType</code> is a 32-bit unsigned integer. But in the
next version:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Version 1.1 of &#39;my_library&#39;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">uint64_t</span> MyType<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> my_library_api<span class="op">(</span>MyType type<span class="op">);</span></span></code></pre></div>
<p><code>MyType</code> is updated to a 64-bit integer. This change
maintains <strong>Source Compatibility</strong> (the code still
compiles) but breaks <strong>Binary Compatibility</strong>. Binary
compatibility is lost because the binary interface of the library, has
changed due to the increased size of <code>MyType</code>.</p>
<p>Maintaining binary compatibility is vital for the stability of
systems, especially when updating shared libraries. It allows users to
upgrade software without disrupting existing functionalities.</p>
<h3 id="audio-plugins">2.1.2 Audio Plugins</h3>
<p>In the realm of audio plugins, two primary components define their
structure: the realtime audio section and the control section.</p>
<figure id="fig:plugbasic">
<img src="./images/audio-plugin-basic.png"
alt="basic audio plugin architecture" />
<figcaption>Figure 2: basic audio plugin architecture</figcaption>
</figure>
<p><em>fig. 2</em>, shows a typical plugin interface with two distinct
colors for clarity. The green section represents the plugin’s
interaction with the host through a low-priority main thread. This part
primarily manages tasks like GUI setup and other control functions. “Low
priority” means that it can handle non-deterministic operations, which
may briefly pause execution.</p>
<p>The red segment signifies that the API is being invoked by a
high-priority realtime thread. These functions are called frequently and
demand minimal latency to promptly respond to the host. They process all
incoming events from the host, including parameter changes and other
vital events essential for audio processing. For instance, a gain
plugin; A typical gain modifies the output volume and possesses a single
parameter: the desired gain in decibels to amplify or diminish the
output audio.<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></p>
<figure>
<img src="./images/realtime-overview.png" style="width:77.0%"
alt="Realtime overview" />
<figcaption aria-hidden="true">Realtime overview</figcaption>
</figure>
<p>A challenge in audio programming stems from the rapidity with which
the audio callback needs a response. The standard structure unfolds
as:</p>
<ol type="1">
<li>The host routinely invokes a process function, forwarding audio
buffers, along with any events related to the audio plugin (such as a
user adjusting a dial within the host).</li>
<li>The plugin must swiftly act on these values and compute its
functionality based on these input parameters. Given that a GUI is often
integrated, synchronization with the audio engine’s events is vital.
Once all events are processed, these changes are communicated back to
the GUI.</li>
</ol>
<p>Failure to meet the callback’s deadline, perhaps due to extended
previous processing, can lead to audio disruptions and glitches. Such
inconsistencies are detrimental to professional audio and must be
diligently avoided. Therefore, it’s essential to prioritize punctuality
and precision in all aspects of audio work<span class="citation"
data-cites="rtaudio">[5]</span>. Keeping in mind the simple but crucial
reminder:</p>
<blockquote>
<p>Don’t miss your Deadline!</p>
</blockquote>
<p><span id="eq:rt_callback"><span class="math display">$$
\frac{\text{AudioBufferSize}}{\text{SamplingFrequency}} =
\text{CallbackFrequency} \\
\quad\text{, e.g.}\quad\frac{512}{48000\text{Hz}} = 10.67\text{ms}
\qquad{(1)}$$</span></span></p>
<p>The equation above presents the formula for determining the minimum
frequency at which the processing function must supply audio samples to
prevent glitches and drop-outs. For 512 individual sampling points, at a
sample rate of 48’000 samples per second, the callback frequency stands
at <strong>10.67ms</strong>. Audio block-size generally fluctuates
between 128 - 2048 samples, with sampling rates ranging from 48’000 -
192’000 Hz. Consequently, our callback algorithm must operate within
approximately <strong>2.9ms - 46.4ms</strong> for optimal
functionality<span class="citation"
data-cites="audiolatency">[2]</span>.</p>
<p>However, this is just the tip of the iceberg. The real challenge lies
in crafting algorithms and data structures that adhere to these
specifications. Drawing a comparison between the constraints of a
realtime thread and a normal thread brings this into sharper focus: In a
realtime thread, responses must meet specific deadlines, ensuring
immediate and predictable behavior. In contrast, a normal thread has
more flexibility in its operation, allowing for variable response times
without the demanding need for timely execution.</p>
<table>
<caption>Realtime limitations. <a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a></caption>
<thead>
<tr class="header">
<th>Problems to Real-time</th>
<th>Real-time</th>
<th>Non-real-time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CPU work</td>
<td><strong>+</strong></td>
<td><strong>+</strong></td>
</tr>
<tr class="even">
<td>Context switches</td>
<td><strong>+</strong> (avoid)</td>
<td><strong>+</strong></td>
</tr>
<tr class="odd">
<td>Memory access</td>
<td><strong>+</strong> (non-paged)</td>
<td><strong>+</strong></td>
</tr>
<tr class="even">
<td>System calls</td>
<td><strong>x</strong></td>
<td><strong>+</strong></td>
</tr>
<tr class="odd">
<td>Allocations</td>
<td><strong>x</strong></td>
<td><strong>+</strong></td>
</tr>
<tr class="even">
<td>Deallocations</td>
<td><strong>x</strong></td>
<td><strong>+</strong></td>
</tr>
<tr class="odd">
<td>Exceptions</td>
<td><strong>x</strong></td>
<td><strong>+</strong></td>
</tr>
<tr class="even">
<td>Priority Inversion</td>
<td><strong>x</strong></td>
<td><strong>+</strong></td>
</tr>
</tbody>
</table>
<p>The above table compares realtime to non-realtime requirements. In
short we can’t use anything that has non-deterministic behavior. We want
to know exactly how long a specific instruction takes to create an
overall structure that provides a deterministic behavior. <em>System
calls</em> or calls into the operating system kernel, are one of such
non-deterministic behaviors. They also include allocations and
deallocations. None of those mechanisms can be used when we deal with
realtime requirements. This results in careful design decisions that
have to be taken when designing such systems. We have to foresee many
aspects of the architecture and use pre-allocated containers and
structures to prevent a non-deterministic behavior. For example to
communicate with the main thread of we often use non-blocking and wait
free data structures as FIFO<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a> queues or ring-buffers
to complement this.</p>
<figure id="fig:rtranking">
<img src="./images/realtime-scala.png" style="width:77.0%"
alt="Realtime ranking" />
<figcaption>Figure 3: Realtime ranking</figcaption>
</figure>
<p><em>fig. 3</em> classifies various realtime systems by their severity
(Y-axis) and the impact on overall design (X-axis). Realtime can be
partitioned into three categories: Soft-Realtime, Firm-Realtime, and
Hard-Realtime. High-severity lapses might have catastrophic
consequences. For instance, in medical monitoring systems or car braking
systems, missing a deadline can be fatal, leading to a literal
<strong>dead</strong>line. Audio sits in the middle, where a missed
deadline compromises professional utility but doesn’t pose dire threats.
Video game rendering bears even lesser severity, as occasional frame
drops don’t render the product ineffectual and are relatively
commonplace.</p>
<h3 id="standards-and-hosts">2.1.3 Standards and Hosts</h3>
<p>Over time, various audio plugin standards have evolved, but only a
select few remain significant today. The table below provides an
overview of some of the most well-recognized standards:</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 10%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 15%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>Standard</th>
<th>Extended Name</th>
<th>Developer</th>
<th>File Extension</th>
<th>Supported OS</th>
<th>Initial Release</th>
<th>Licensing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://cleveraudio.org/">CLAP</a></td>
<td>Clever Audio Plugin</td>
<td>Bitwig &amp; U-he</td>
<td>.clap</td>
<td>Windows, MacOS &amp; Linux</td>
<td>2022</td>
<td>MIT</td>
</tr>
<tr class="even">
<td><a
href="https://steinbergmedia.github.io/vst3_dev_portal/pages/index.html">VST/VST3</a></td>
<td>Virtual Studio Technology</td>
<td>Steinberg</td>
<td>.dll, .vst, .vst3</td>
<td>Windows, MacOS &amp; Linux</td>
<td>2017</td>
<td>GPLv3, Steinberg Dual License</td>
</tr>
<tr class="odd">
<td><a href="https://apps.avid.com/aax-portal/">AAX</a></td>
<td>Avid Audio Extension</td>
<td>Pro Tools (Avid)</td>
<td>.aax</td>
<td>Windows &amp; MacOS</td>
<td>2011</td>
<td>Approved Partner</td>
</tr>
<tr class="even">
<td><a
href="https://developer.apple.com/documentation/audiotoolbox/audio_unit_v3_plug-ins">AU</a></td>
<td>Audio Units</td>
<td>Apple macOS &amp; iOS</td>
<td>.AU</td>
<td>MacOS</td>
<td>“Cheetah” 2001</td>
<td>Custom License Agreement</td>
</tr>
</tbody>
</table>
<p>Certain standards cater specifically to particular platforms or
programs. For instance, Apple’s <strong>AU</strong> is seamlessly
integrated with their core audio SDK<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a> <span class="citation"
data-cites="applecoreaudio">[1]</span>. Similarly, Avid’s
<strong>AAX</strong> is designed exclusively for plugin compatibility
with the <a href="https://www.avid.com/pro-tools">Pro Tools</a> DAW<a
href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>. On the other hand, standards like
the <strong>VST3</strong> SDK are both platform and program independent,
and it’s currently among the most popular plugin standards.
Additionally, the newly introduced <strong>CLAP</strong> standard is
also gaining traction.</p>
<p>Most commonly, these plugins are hosted within <strong>Digital Audio
Workstations (DAWs)</strong>. These software applications facilitate
tasks such as music production, podcast recording, and creating custom
game sound designs. Their applicability spans a broad spectrum, and
numerous DAW manufacturers exist:</p>
<figure>
<img src="./images/plugin-hosts.png" alt="plugin hosts" />
<figcaption aria-hidden="true">plugin hosts</figcaption>
</figure>
<p>However, DAWs are not the only plugin hosts. Often, plugin developers
include a <em>standalone</em> version that operates independently of
other software. A recent noteworthy development in this domain is the
game industry’s move towards these plugins, exemplified by Unreal
Engine’s forthcoming support for the <strong>CLAP</strong> standard, as
unveiled at <a
href="https://www.youtube.com/watch?v=q9pFsI9Cq9c&amp;t=621s">Unreal
Fest 2022</a>.</p>
<h2 id="the-clap-audio-plugin-standard">2.2 The CLAP Audio Plugin
Standard</h2>
<p>Originating from the collaboration between Berlin-based companies
Bitwig and u-he, CLAP (<strong>CL</strong>ever <strong>A</strong>udio
<strong>P</strong>lugin) emerged as a new plugin standard. Born from
developer Alexandre Bique’s vision in 2014, it was revitalized in 2021
with a focus on three core concepts: Simplicity, Clarity, and
Robustness.</p>
<p>CLAP stands out for its:</p>
<ul>
<li><em>Consistent API</em> and <em>flat architecture</em>, making
plugin creation more intuitive.</li>
<li><em>Adaptability</em>, allowing flexible integration of unique
features like per-voice modulation (MPE<a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> on
steroids) or a host thread-pool extension.</li>
<li>Open-source ethos, making the standard accessible under the <a
href="https://en.wikipedia.org/wiki/MIT_License">MIT License</a>.</li>
</ul>
<p>CLAP establishes a stable and backward compatible Application Binary
Interface. This ABI forms a bridge for communication between digital
audio workstations and audio plugins such as synthesizers and effect
units.</p>
<h3 id="clap-basics">2.2.1 CLAP basics</h3>
<p>The principal advantage of CLAP is its simplicity. In contrast to
other plugin standards, such as VST, which often involve complex
structures including deep inheritance hierarchies that complicate both
debugging and understanding the code, CLAP offers a refreshingly
straightforward and flat architecture. With CLAP, a single exported
symbol is the foundation from which the entire plugin functionality
extends: the <code>clap_plugin_entry</code> type. This must be made
available by the DSO and is the only exported symbol.</p>
<blockquote>
<p>Note: We will use the term <em>CLAP</em> to refer to the DSO that
houses the plugin implementation of the clap interface. This is a common
phrase in the CLAP community.</p>
</blockquote>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// &lt;clap/entry.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> clap_plugin_entry <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">clap_version_t</span> clap_version<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">bool</span><span class="op">(</span>CLAP_ABI <span class="op">*</span>init<span class="op">)(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>plugin_path<span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span><span class="op">(</span>CLAP_ABI <span class="op">*</span>deinit<span class="op">)(</span><span class="dt">void</span><span class="op">);</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>   <span class="at">const</span> <span class="dt">void</span> <span class="op">*(</span>CLAP_ABI <span class="op">*</span>get_factory<span class="op">)(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>factory_id<span class="op">);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="dt">clap_plugin_entry_t</span><span class="op">;</span></span></code></pre></div>
<p>The <code>clap_version_t</code> type specifies the version the plugin
is created with. Following this, there are three function pointers
declared:</p>
<ol type="1">
<li>The initialization function <code>bool init(const char*)</code> is
the first function called by the host. It is primarily used for plugin
scanning and is designed to execute quickly.</li>
<li>The de-initialization function <code>void deinit(void)</code> is
invoked when the DSO is unloaded, which typically occurs after the final
plugin instance is closed.</li>
<li>The <code>const void* get_factory(const char*)</code> serves as the
“constructor” for the plugin, tasked with creating new plugin instances.
A notable aspect of CLAP plugins is their containerized nature, allowing
a single DSO to encapsulate multiple distinct plugins.</li>
</ol>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> clap_plugin_factory <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">uint32_t</span><span class="op">(</span>CLAP_ABI <span class="op">*</span>get_plugin_count<span class="op">)(</span><span class="at">const</span> <span class="kw">struct</span> clap_plugin_factory <span class="op">*</span>factory<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>   <span class="at">const</span> <span class="dt">clap_plugin_descriptor_t</span> <span class="op">*(</span>CLAP_ABI <span class="op">*</span>get_plugin_descriptor<span class="op">)(</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">struct</span> clap_plugin_factory <span class="op">*</span>factory<span class="op">,</span> <span class="dt">uint32_t</span> index<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>   <span class="at">const</span> <span class="dt">clap_plugin_t</span> <span class="op">*(</span>CLAP_ABI <span class="op">*</span>create_plugin<span class="op">)(</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">struct</span> clap_plugin_factory <span class="op">*</span>factory<span class="op">,</span> <span class="at">const</span> <span class="dt">clap_host_t</span> <span class="op">*</span>host<span class="op">,</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>plugin_id<span class="op">);</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="dt">clap_plugin_factory_t</span><span class="op">;</span></span></code></pre></div>
<p>The plugin factory acts as a hub for creating plugin instances within
a given CLAP object. The structure requires three function pointers:</p>
<ol type="1">
<li><code>get_plugin_count(~)</code> determines the number of distinct
plugins available within the CLAP.</li>
<li><code>get_plugin_descriptor(~)</code> retrieves a description of
each plugin, which is used by the host to present information about the
plugin to users.</li>
<li><code>create_plugin(~)</code> is responsible for instantiating the
plugin(s).</li>
</ol>
<p>At the heart of the communication between the host and a plugin is
the <code>clap_plugin_t</code> type. It defines the essential functions
that a host will invoke to control the plugin, such as initializing,
processing audio, and handling events. It is through this interface that
the plugin exposes its capabilities and responds to the host, thereby
allowing for the dynamic and interactive processes required for audio
manipulation and creation.</p>
<figure>
<img src="./images/clap_factory.png" style="width:77.0%"
alt="CLAP factory" />
<figcaption aria-hidden="true">CLAP factory</figcaption>
</figure>
<h3 id="creating-a-clap-plugin">2.2.2 Creating a CLAP Plugin</h3>
<p>To illustrate the ease with which one can get started with CLAP, we
will develop a simple gain plugin, a basic yet foundational tool in
audio processing. A gain plugin’s role is to control the output volume
by adjusting the input signal’s level in decibels. Accordingly, our
plugin will manage the audio inputs and outputs and feature a single
adjustable parameter: gain.</p>
<p>Setting up our project is straightforward. We’ll create a directory
for our plugin, obtain the CLAP library, and prepare the initial
files:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> mini_clap <span class="kw">&amp;&amp;</span> <span class="bu">cd</span> mini_clap</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/free-audio/clap.git</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">touch</span> mini_gain.cpp</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">touch</span> CMakeLists.txt</span></code></pre></div>
<p>Next, we’ll configure the build system:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">cmake_minimum_required</span>(<span class="ot">VERSION</span> <span class="dt">3.2</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">project</span>(MiniGain <span class="ot">LANGUAGES</span> <span class="ot">C</span> <span class="ot">CXX</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(<span class="dv">CMAKE_CXX_STANDARD</span> 20)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(<span class="dv">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="ot">ON</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span>(target mini_gain)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">add_library</span>(<span class="dv">${target}</span> <span class="bn">SHARED</span> mini_gain.cpp)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co"># CLAP is a header-only library, so we just need to include it</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="kw">target_include_directories</span>(<span class="dv">${target}</span> <span class="bn">PRIVATE</span> clap/include)</span></code></pre></div>
<p>This CMake snippet sets up the build environment for our
<em>MiniGain</em> project. We enable C++20 to use the latest language
features and declare a shared library named <code>mini_gain</code> which
will be built from mini_gain.cpp.</p>
<p>To meet the CLAP naming conventions, we need to modify the library’s
output name:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A CLAP is just a renamed shared library</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set_target_properties</span>(<span class="dv">${target}</span> <span class="ot">PROPERTIES</span> <span class="ot">PREFIX</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">set_target_properties</span>(<span class="dv">${target}</span> <span class="ot">PROPERTIES</span> <span class="ot">SUFFIX</span> <span class="st">&quot;.clap&quot;</span>)</span></code></pre></div>
<p>This configuration tells CMake to output our library with the name
<code>mini_gain.clap</code>.</p>
<p>While the output is correctly named, it remains within the build
directory, which isn’t automatically recognized by CLAP hosts. For
practical development, creating a symlink to the expected location is
beneficial. We’ll append a post-build command to do just that:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cmake"><code class="sourceCode cmake"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Default search path for CLAP plugins. See also &lt;clap/entry.h&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="dv">UNIX</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="dv">APPLE</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">set</span>(CLAP_USER_PATH <span class="st">&quot;</span><span class="fl">$ENV{HOME}</span><span class="st">/Library/Audio/Plug-Ins/CLAP&quot;</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>()</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">set</span>(CLAP_USER_PATH <span class="st">&quot;</span><span class="fl">$ENV{HOME}</span><span class="st">/.clap&quot;</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">endif</span>()</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elseif</span>(<span class="dv">WIN32</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span>(CLAP_USER_PATH <span class="st">&quot;</span><span class="fl">$ENV{LOCALAPPDATA}</span><span class="sc">\\</span><span class="st">Programs</span><span class="sc">\\</span><span class="st">Common</span><span class="sc">\\</span><span class="st">CLAP&quot;</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="cf">endif</span>()</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a symlink post-build to make development easier</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="kw">add_custom_command</span>(</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">TARGET</span> <span class="dv">${target}</span> <span class="bn">POST_BUILD</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="bn">COMMAND</span> <span class="dv">${CMAKE_COMMAND}</span> <span class="bn">-E</span> <span class="bn">create_symlink</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;</span><span class="ot">$&lt;</span><span class="kw">TARGET_FILE</span><span class="ot">:</span><span class="dv">${target}</span><span class="ot">&gt;</span><span class="st">&quot;</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;</span><span class="dv">${CLAP_USER_PATH}</span><span class="st">/</span><span class="ot">$&lt;</span><span class="kw">TARGET_FILE_NAME</span><span class="ot">:</span><span class="dv">${target}</span><span class="ot">&gt;</span><span class="st">&quot;</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>We start by defining the entry point for the plugin. Here’s how you
might proceed:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// mini_gain.cpp</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;clap/clap.h&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">// &#39;clap_entry&#39; is the only symbol exported by the plugin.</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> CLAP_EXPORT <span class="at">const</span> clap_plugin_entry clap_entry <span class="op">=</span> <span class="op">{</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>clap_version <span class="op">=</span> CLAP_VERSION<span class="op">,</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Called after the DSO is loaded and before it is unloaded.</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>init <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> path<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">&quot;MiniGain -- initialized: </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> path<span class="op">);</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>deinit <span class="op">=</span> <span class="op">[]()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;MiniGain -- deinitialized</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Provide a factory for creating &#39;MiniGain&#39; instances.</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>get_factory <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> factoryId<span class="op">)</span> <span class="op">-&gt;</span> <span class="at">const</span> <span class="dt">void</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>strcmp<span class="op">(</span>factoryId<span class="op">,</span> CLAP_PLUGIN_FACTORY_ID<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="co">// sanity check</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">&amp;</span>pluginFactory<span class="op">;</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>First, we include the <code>clap.h</code> header file, which
aggregates all components from the CLAP API. We also import some
standard headers for later use and initialize the fields of the
<code>clap_plugin_entry</code> type with simple lambda functions. Our
plugin factory is designed to offer a single plugin within this DSO:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The factory is responsible for creating plugin instances.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> clap_plugin_factory pluginFactory <span class="op">=</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This CLAP has only one plugin to offer</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>get_plugin_count <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">*)</span> <span class="op">-&gt;</span> <span class="dt">uint32_t</span> <span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the metadata for &#39;MiniGain&#39;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>get_plugin_descriptor <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">*,</span> <span class="dt">uint32_t</span> idx<span class="op">)</span> <span class="op">-&gt;</span> <span class="at">const</span> <span class="kw">auto</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>idx <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="op">&amp;</span>MiniGain<span class="op">::</span>Descriptor <span class="op">:</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a plugin if the IDs match.</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>create_plugin <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">*,</span> <span class="at">const</span> clap_host<span class="op">*</span> host<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> id<span class="op">)</span> <span class="op">-&gt;</span> <span class="at">const</span> <span class="kw">auto</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>strcmp<span class="op">(</span>id<span class="op">,</span> MiniGain<span class="op">::</span>Descriptor<span class="op">.</span>id<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> MiniGain<span class="op">::</span>create<span class="op">(</span>host<span class="op">);</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>clap_plugin<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The <code>host</code> pointer serves as a means of communication from
the plugin towards the host, requesting necessary services and
functionality.</p>
<p>The implementation of our plugin in modern C++ requires a mechanism
to interact with the C-API of the CLAP standard. Since the
<code>clap_plugin_t</code> struct expects static function pointers and
member functions are not static, we resolve this mismatch using
<em>trampoline</em> functions, also known as <em>glue</em> routines.
These functions connect the static world of the C-API with the
instance-specific context of our C++ classes:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>MiniGain<span class="op">*</span> MiniGain<span class="op">::</span>self<span class="op">(</span><span class="at">const</span> clap_plugin <span class="op">*</span>plugin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cast plugin_data back to MiniGain* to retrieve the class instance.</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>MiniGain<span class="op">*&gt;(</span>plugin<span class="op">-&gt;</span>plugin_data<span class="op">);</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">// A glue layer between our C++ class and the C API.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> MiniGain<span class="op">::</span>initializePlugin<span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>desc <span class="op">=</span> <span class="op">&amp;</span>Descriptor<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>plugin_data <span class="op">=</span> <span class="kw">this</span><span class="op">;</span> <span class="co">// Link this instance with the plugin data.</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>destroy <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        self<span class="op">(</span>p<span class="op">)-&gt;</span>destroy<span class="op">();</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>process <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*</span> p<span class="op">,</span> <span class="at">const</span> clap_process<span class="op">*</span> proc<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> self<span class="op">(</span>p<span class="op">)-&gt;</span>process<span class="op">(</span>proc<span class="op">);</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>get_extension <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*</span> p<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> id<span class="op">)</span> <span class="op">-&gt;</span> <span class="at">const</span> <span class="dt">void</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: Add extensions.</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Simplified for brevity.</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>init <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>activate <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>deactivate <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{};</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>start_processing <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>stop_processing <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{};</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>reset <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{};</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    mPlugin<span class="op">.</span>on_main_thread <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{};</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The code sets up glue routines to redirect calls from the static C
API to our C++ class methods. The <code>self</code> function retrieves
the class instance from <code>plugin_data</code>, facilitating the call
to the relevant member functions. We focus on <code>destroy</code> and
<code>process</code>, with other functions returning defaults to
streamline our plugin’s integration with the host.</p>
<p>Finally we create the <code>MiniGain</code> class which encapsulates
the functionality of our plugin:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MiniGain <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="at">static</span> <span class="at">const</span> clap_plugin_descriptor Descriptor <span class="op">=</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>clap_version <span class="op">=</span> CLAP_VERSION<span class="op">,</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>id <span class="op">=</span> <span class="st">&quot;mini.gain&quot;</span><span class="op">,</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;MiniGain&quot;</span><span class="op">,</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>vendor <span class="op">=</span> <span class="st">&quot;Example&quot;</span><span class="op">,</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>version <span class="op">=</span> <span class="st">&quot;1.0.0&quot;</span><span class="op">,</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>description <span class="op">=</span> <span class="st">&quot;A Minimal CLAP plugin&quot;</span><span class="op">,</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>features <span class="op">=</span> <span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*[]){</span> CLAP_PLUGIN_FEATURE_MIXING<span class="op">,</span> <span class="kw">nullptr</span> <span class="op">}</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> clap_plugin<span class="op">*</span> create<span class="op">(</span><span class="at">const</span> clap_host <span class="op">*</span>host<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> -- Creating instance for host: &lt;</span><span class="sc">{}</span><span class="st">, v</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">&gt;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>            Descriptor<span class="op">.</span>name<span class="op">,</span> host<span class="op">-&gt;</span>name<span class="op">,</span> host<span class="op">-&gt;</span>version<span class="op">,</span> pluginInstances<span class="op">.</span>size<span class="op">()</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">[</span>plug<span class="op">,</span> success<span class="op">]</span> <span class="op">=</span> pluginInstances<span class="op">.</span>emplace<span class="op">(</span><span class="kw">new</span> MiniGain<span class="op">(</span>host<span class="op">));</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> success <span class="op">?</span> <span class="op">&amp;(*</span>plug<span class="op">)-&gt;</span>mPlugin <span class="op">:</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> destroy<span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        pluginInstances<span class="op">.</span>erase<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="bu">std::</span>format<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> -- Destroying instance. </span><span class="sc">{}</span><span class="st"> plugins left</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            Descriptor<span class="op">.</span>name<span class="op">,</span> pluginInstances<span class="op">.</span>size<span class="op">()</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    clap_process_status process<span class="op">(</span><span class="at">const</span> clap_process <span class="op">*</span>process<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{};</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: Implement processing logic.</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> MiniGain<span class="op">(</span><span class="at">const</span> clap_host <span class="op">*</span>host<span class="op">)</span> <span class="op">:</span> mHost<span class="op">(</span>host<span class="op">)</span> <span class="op">{</span> initializePlugin<span class="op">();</span> <span class="op">}</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> MiniGain <span class="op">*</span>self<span class="op">(</span><span class="at">const</span> clap_plugin <span class="op">*</span>plugin<span class="op">);</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> initializePlugin<span class="op">();</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// private members:</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="at">const</span> clap_host <span class="op">*</span>mHost <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>    clap_plugin mPlugin <span class="op">=</span> <span class="op">{};</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="at">static</span> <span class="bu">std::</span>set<span class="op">&lt;</span>MiniGain<span class="op">*&gt;</span> pluginInstances<span class="op">{};</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The <code>Descriptor</code> in the MiniGain class contains essential
metadata for the plugin, including identifiers and versioning. The
create function allocates a plugin instance and stores it inside a
static <code>std::set</code>. Overall, this minimalistic plugin
structure is achieved in approximately 100 lines of code.</p>
<figure>
<img src="./images/clap_mini_hosted.png" alt="MiniGain hosted" />
<figcaption aria-hidden="true">MiniGain hosted</figcaption>
</figure>
<p>This implementation of the MiniGain plugin is already sufficient for
it to be recognized and loaded by CLAP-compatible hosts. At this stage,
a developer might wonder about how to debug such a plugin, considering
it operates as a shared library that has to be loaded and called.</p>
<h3 id="debugging">2.2.3 Debugging</h3>
<p>Debugging is a crucial step in software development. When the
complexity of our program increases or even if we just want to verify
correct behavior, it is great to step through the code with debuggers
such as <a href="https://www.sourceware.org/gdb/">gdb</a> or <a
href="https://lldb.llvm.org/">lldb</a>.</p>
<p>When developing shared objects, debugging introduces an additional
layer of complexity. We rely upon a host that has the CLAP standard
implemented and all features supported.</p>
<p>Fortunately, Bitwig offers a streamlined approach to this challenge.
Since their audio engine runs as a standalone executable, we can simply
start it with a debugger and latch onto the breakpoints of our plugin.
To set up debugging in Bitwig, carry out the following steps:</p>
<ol type="1">
<li>Bitwig supports different hosting modes. For debugging purposes, we
want the plugin to be loaded within the same thread as the audio engine,
so we use <strong>Within Bitwig</strong></li>
</ol>
<figure>
<img src="./images/bitwig_hosting.png" style="width:77.0%"
alt="Bitwig Hosting" />
<figcaption aria-hidden="true">Bitwig Hosting</figcaption>
</figure>
<ol start="2" type="1">
<li>If the audio engine is running, we must first shut it down. Do this
by right-clicking in the transport bar and choosing <strong>terminate
audio engine</strong>.</li>
</ol>
<p>Now we can execute the audio engine with the debugger of choice. The
executable is located inside Bitwigs installation directory. On my linux
machine this would be:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gdb</span> /opt/bitwig-studio/bin/BitwigAudioEngine-X64-AVX2</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">run</span></span></code></pre></div>
<p>With the debugger running, you’ll have access to debugging tools, and
you can monitor the console output for any print statements. For
instance, here’s what you might see when creating and then removing
three instances of the <code>MiniGain</code> plugin:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> initialized: /home/wayn/.clap/mini_gain.clap</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> Creating instance for host: <span class="op">&lt;</span>Bitwig Studio, v5.0.7, <span class="dv">0</span><span class="op">&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> Creating instance for host: <span class="op">&lt;</span>Bitwig Studio, v5.0.7, <span class="dv">1</span><span class="op">&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> Creating instance for host: <span class="op">&lt;</span>Bitwig Studio, v5.0.7, <span class="dv">2</span><span class="op">&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="ex">PluginHost:</span> Destroying plugin with id 3</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> Destroying instance. 2 plugins left</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="ex">PluginHost:</span> Destroying plugin with id 2</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> Destroying instance. 1 plugins left</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="ex">PluginHost:</span> Destroying plugin with id 1</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="ex">MiniGain</span> <span class="at">--</span> Destroying instance. 0 plugins left</span></code></pre></div>
<h3 id="extensions">2.2.4 Extensions</h3>
<p>The MiniGain plugin, in its current state, is not yet operational due
to the absence of needed extensions. While the fundamental framework of
the plugin has been established, the extensions are key to unlocking its
full potential. The CLAP repository’s <code>ext/</code> directory is
home to a range of extensions, including <em>gui</em> and
<em>state</em>, among others. To fulfill our plugin’s requirements of
managing a parameter and processing an audio input and output, we focus
on incorporating the <strong>audio-ports</strong> and
<strong>params</strong> extensions:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setParamGain<span class="op">(</span><span class="dt">double</span> value<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> mParamGain <span class="op">=</span> value<span class="op">;</span> <span class="op">}</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> paramGain<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> mParamGain<span class="op">;</span> <span class="op">}</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> MiniGain<span class="op">(</span><span class="at">const</span> clap_host <span class="op">*</span>host<span class="op">)</span> <span class="op">:</span> mHost<span class="op">(</span>host<span class="op">)</span> <span class="op">{</span> initialize<span class="op">();</span> <span class="op">}</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> initialize<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        initializePlugin<span class="op">();</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        initializeExtAudioPorts<span class="op">();</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        initializeExtParams<span class="op">();</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> initializePlugin<span class="op">();</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> initializeExtAudioPorts<span class="op">();</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> initializeExtParams<span class="op">();</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    clap_plugin_audio_ports mExtAudioPorts <span class="op">=</span> <span class="op">{};</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    clap_plugin_params mExtParams <span class="op">=</span> <span class="op">{};</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> mParamGain <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>We add an initialization function that bundles the setup processes
for these extensions. We maintain the parameter value in a dedicated
variable and provide access through getters and setters. Finally, to
utilize these extensions, the plugin communicates the supported
functionalities back to the host:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// initializePlugin() {</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>get_extension <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*</span> p<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> id<span class="op">)</span> <span class="op">-&gt;</span> <span class="at">const</span> <span class="dt">void</span><span class="op">*</span> <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>strcmp<span class="op">(</span>id<span class="op">,</span> CLAP_EXT_PARAMS<span class="op">))</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">&amp;</span>self<span class="op">(</span>p<span class="op">)-&gt;</span>mExtParams<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(!</span>strcmp<span class="op">(</span>id<span class="op">,</span> CLAP_EXT_AUDIO_PORTS<span class="op">))</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">&amp;</span>self<span class="op">(</span>p<span class="op">)-&gt;</span>mExtAudioPorts<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>The host determines the plugin’s supported extensions by calling this
function with all supported extension IDs. This ensures the host
recognizes the plugin’s capabilities. For MiniGain, the next step
involves implementing the audio-ports extension as follows:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> MiniGain<span class="op">::</span>initializeExtAudioPorts<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    mExtAudioPorts <span class="op">=</span> <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>count <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*,</span> <span class="dt">bool</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">uint32_t</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">},</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>get <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*,</span> <span class="dt">uint32_t</span> index<span class="op">,</span> <span class="dt">bool</span> isInput<span class="op">,</span> clap_audio_port_info <span class="op">*</span>info<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>index <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>id <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>snprintf<span class="op">(</span>info<span class="op">-&gt;</span>name<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>info<span class="op">-&gt;</span>name<span class="op">),</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> Descriptor<span class="op">.</span>name<span class="op">,</span> isInput <span class="op">?</span> <span class="st">&quot;IN&quot;</span> <span class="op">:</span> <span class="st">&quot;OUT&quot;</span><span class="op">);</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>channel_count <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Stereo</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>flags <span class="op">=</span> CLAP_AUDIO_PORT_IS_MAIN<span class="op">;</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span><span class="dt">port_type</span> <span class="op">=</span> CLAP_PORT_STEREO<span class="op">;</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>in_place_pair <span class="op">=</span> CLAP_INVALID_ID<span class="op">;</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With the <code>count</code> function, the plugin notifies the host
about the plugin’s audio input and output capabilities . The
<code>get</code> function further details the configuration, marking a
stereo channel setup. This establishes the essential framework for the
plugin to access audio input and output streams during the process
callback.</p>
<p>The parameter extension in MiniGain outlines the parameters the
plugin possesses and provides metadata about them. The initialization
function for the extension is defined as follows:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> MiniGain<span class="op">::</span>initializeExtParams<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    mExtParams <span class="op">=</span> <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>count <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*)</span> <span class="op">-&gt;</span> <span class="dt">uint32_t</span> <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Single parameter for gain</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>get_info <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*,</span> <span class="dt">uint32_t</span> index<span class="op">,</span> clap_param_info <span class="op">*</span>info<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>index <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>id <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>flags <span class="op">=</span> CLAP_PARAM_IS_AUTOMATABLE<span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>cookie <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>snprintf<span class="op">(</span>info<span class="op">-&gt;</span>name<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>info<span class="op">-&gt;</span>name<span class="op">),</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;Gain&quot;</span><span class="op">);</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>snprintf<span class="op">(</span>info<span class="op">-&gt;</span><span class="kw">module</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>info<span class="op">-&gt;</span><span class="kw">module</span><span class="op">),</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> MiniGain<span class="op">::</span>Descriptor<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Module&quot;</span><span class="op">);</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>min_value <span class="op">=</span> <span class="op">-</span><span class="fl">40.0</span><span class="op">;</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>max_value <span class="op">=</span> <span class="fl">40.0</span><span class="op">;</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            info<span class="op">-&gt;</span>default_value <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span></code></pre></div>
<p>Here, <code>count</code> reveals that the plugin hosts a single gain
parameter, and <code>get_info</code> provides crucial details such as
the parameter’s range and default setting.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>get_value <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*</span> p<span class="op">,</span> clap_id id<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>out<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>id <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>out <span class="op">=</span> self<span class="op">(</span>p<span class="op">)-&gt;</span>paramGain<span class="op">();</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>value_to_text <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*,</span> clap_id id<span class="op">,</span> <span class="dt">double</span> value<span class="op">,</span> <span class="dt">char</span><span class="op">*</span> out<span class="op">,</span> <span class="dt">uint32_t</span> outSize<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>id <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>snprintf<span class="op">(</span>out<span class="op">,</span> outSize<span class="op">,</span> <span class="st">&quot;</span><span class="sc">%g</span><span class="st"> </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> value<span class="op">,</span> <span class="st">&quot; dB&quot;</span><span class="op">);</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>text_to_value <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*,</span> clap_id id<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> text<span class="op">,</span> <span class="dt">double</span><span class="op">*</span> out<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>id <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>out <span class="op">=</span> <span class="bu">std::</span>strtod<span class="op">(</span>text<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>flush <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> clap_plugin<span class="op">*,</span> <span class="at">const</span> <span class="kw">auto</span><span class="op">*,</span> <span class="at">const</span> <span class="kw">auto</span><span class="op">*)</span> <span class="op">{</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// noop</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The parameter’s current value is fetched using
<code>get_value</code>, while <code>value_to_text</code> and
<code>text_to_value</code> manage the conversion between numerical
values and user-readable text, appending ‘dB’ to indicate decibels. With
these definitions, compiling and loading the plugin into a host will now
allow us to interact with the parameter.</p>
<figure>
<img src="./images/clap_minigain_hosted.png" style="width:33.0%"
alt="MiniGain hosted" />
<figcaption aria-hidden="true">MiniGain hosted</figcaption>
</figure>
<h3 id="processing">2.2.5 Processing</h3>
<p>To make the <em>MiniGain</em> plugin fully functional, we must
finally tackle the <code>process</code> callback, which is the heart of
all audio processing and event handling. This function is responsible
for managing audio data and responding to events, such as parameter
changes or MIDI note triggers.</p>
<figure>
<img src="./images/clap_events.png" style="width:66.0%"
alt="CLAP parameter event" />
<figcaption aria-hidden="true">CLAP parameter event</figcaption>
</figure>
<p>CLAP has a sophisticated method for coupling events with audio
buffers. Events come with a header and payload; the header’s
<code>flags</code> denote the payload type, and the payload contains the
event data. In our case, it’s the <code>clap_event_param_value</code>,
carrying information about parameter changes.</p>
<p>The <code>process</code> function works with frames, which
encapsulate both the audio samples and any associated event data in a
time-ordered fashion. This approach ensures that the audio processing is
accurate and responsive to real-time control changes.</p>
<figure>
<img src="./images/clap_process.png" alt="CLAP process" />
<figcaption aria-hidden="true">CLAP process</figcaption>
</figure>
<p>To implement the <code>process</code> function in <em>MiniGain</em>,
we need to write code that iterates through these frames, applies the
gain value to the audio samples, and handles any parameter change
events. It is crucial to ensure that the gain adjustments occur
precisely at the event’s timestamp within the audio buffer to maintain
tight synchronization between user actions and audio output.</p>
<p>By integrating this final piece, we’ll have a working gain plugin
that not only processes audio but also responds dynamically to user
interactions. The code would look something like this:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>clap_process_status process<span class="op">(</span><span class="at">const</span> clap_process <span class="op">*</span>process<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> <span class="op">*</span>inEvents <span class="op">=</span> process<span class="op">-&gt;</span>in_events<span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> numEvents <span class="op">=</span> process<span class="op">-&gt;</span>in_events<span class="op">-&gt;</span>size<span class="op">(</span>inEvents<span class="op">);</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> eventIndex <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> frame <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> frame <span class="op">&lt;</span> process<span class="op">-&gt;</span>frames_count<span class="op">;</span> <span class="op">++</span>frame<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Process all events at given @frame, there may be more than one.</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>eventIndex <span class="op">&lt;</span> numEvents<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> <span class="kw">auto</span> <span class="op">*</span>eventHeader <span class="op">=</span> inEvents<span class="op">-&gt;</span>get<span class="op">(</span>inEvents<span class="op">,</span> eventIndex<span class="op">);</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>eventHeader<span class="op">-&gt;</span>time <span class="op">!=</span> frame<span class="op">)</span> <span class="co">// Consumned all event for @frame</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">switch</span><span class="op">(</span>eventHeader<span class="op">-&gt;</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">case</span> CLAP_EVENT_PARAM_VALUE<span class="op">:</span> <span class="op">{</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>                    <span class="at">const</span> <span class="kw">auto</span> <span class="op">*</span>event <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> clap_event_param_value<span class="op">*&gt;(</span>eventHeader<span class="op">);</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// Since we only interact with the parameter from this</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// thread we don&#39;t need to synchronize access to it.</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>event<span class="op">-&gt;</span>param_id <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>                        setParamGain<span class="op">(</span>event<span class="op">-&gt;</span>value<span class="op">);</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">};</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>eventIndex<span class="op">;</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Process audio for given @frame.</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> gain <span class="op">=</span> <span class="bu">std::</span>pow<span class="op">(</span><span class="fl">10.0</span><span class="bu">f</span><span class="op">,</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;(</span>paramGain<span class="op">())</span> <span class="op">/</span> <span class="fl">20.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> inputL <span class="op">=</span> process<span class="op">-&gt;</span>audio_inputs<span class="op">-&gt;</span>data32<span class="op">[</span><span class="dv">0</span><span class="op">][</span>frame<span class="op">];</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">float</span> inputR <span class="op">=</span> process<span class="op">-&gt;</span>audio_inputs<span class="op">-&gt;</span>data32<span class="op">[</span><span class="dv">1</span><span class="op">][</span>frame<span class="op">];</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>        process<span class="op">-&gt;</span>audio_outputs<span class="op">-&gt;</span>data32<span class="op">[</span><span class="dv">0</span><span class="op">][</span>frame<span class="op">]</span> <span class="op">=</span> inputL <span class="op">*</span> gain<span class="op">;</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>        process<span class="op">-&gt;</span>audio_outputs<span class="op">-&gt;</span>data32<span class="op">[</span><span class="dv">1</span><span class="op">][</span>frame<span class="op">]</span> <span class="op">=</span> inputR <span class="op">*</span> gain<span class="op">;</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> CLAP_PROCESS_SLEEP<span class="op">;</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The specific implementation will involve fetching the gain parameter,
responding to parameter events, and manipulating the audio buffer
accordingly. Once implemented, compiling and running the plugin should
yield a controllable gain effect within the host application.</p>
<h2 id="grpc---remote-procedure-calls">2.3 gRPC - Remote Procedure
Calls</h2>
<p>In today’s fast-paced software development landscape, there is a
growing need for efficient communication between various software
systems. Addressing this demand, <a href="https://grpc.io/">gRPC</a>,
which stands for <em>g Remote Procedure Calls</em>, has risen as an
open-source framework specifically tailored for this purpose. If you
want to find out about the current meaning of <a
href="https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md">g</a>
in gRPC, please consult the official documentation for clearance as it
changes between versions. Its standout features include impressive
speed, compatibility with a wide range of programming languages, and a
steadily increasing adoption rate. These attributes have positioned gRPC
as a leading choice for inter-service communication in contemporary
software architecture.</p>
<figure>
<img src="./images/grpc_langs.png" style="width:66.0%"
alt="gRPC supported languages" />
<figcaption aria-hidden="true">gRPC supported languages</figcaption>
</figure>
<h3 id="protobuf">2.3.1 Protobuf</h3>
<p>Central to gRPC’s efficiency and flexibility is the <em>Protocol
Buffer</em>, often abbreviated as protobuf. Developed by Google,
protobuf is a serialization format that efficiently converts structured
data into a format optimized for smooth transmission and reception.</p>
<h4 id="the-rationale-behind-protobuf">The Rationale Behind
Protobuf</h4>
<p>Traditionally, data interchange between systems utilized formats such
as XML or JSON. While these formats are human-readable and widely
accepted, they can be quite verbose. This increased verbosity can slow
down transmission and demand more storage, leading to potential
inefficiencies. In contrast, protobuf offers a concise binary format,
resulting in faster transmission and reduced data overhead, positioning
it as a preferred choice for many developers<span class="citation"
data-cites="performanceprotobufIoT">[4]</span>.</p>
<h4 id="flexibility-in-design">Flexibility in Design</h4>
<p>A standout feature of protobuf is its universal approach. Developers
can outline their data structures and services using an <em>Interface
Definition Language</em> (IDL). IDLs are used to define data structures
and interfaces in a language-neutral manner, ensuring they can be used
across various platforms and languages. Once defined, this IDL can be
compiled to produce libraries that are compatible with numerous
programming languages<span class="citation"
data-cites="protobufcasestudy">[3]</span>, ensuring coherence even when
different system components are developed in diverse languages.</p>
<h4 id="seamless-evolution">Seamless Evolution</h4>
<p>As software services continually evolve, it’s essential that changes
do not disrupt existing functionalities. Protobuf’s design flexibility
allows for such evolutions without hindering compatibility. This
adaptability ensures newer versions of a service can integrate
seamlessly with older versions, ensuring consistent functionality<span
class="citation" data-cites="performanceprotobufIoT">[4]</span>.</p>
<p>To encapsulate, protobuf’s attributes include:</p>
<ul>
<li>A compact binary format for quick serialization and deserialization,
ideal for performance-critical applications.</li>
<li>Schema evolution capabilities, enabling developers to modify their
data structures without affecting the integrity of existing serialized
data.</li>
<li>Strongly typed data structures, ensuring data exchanged between
services adhere strictly to the specified schema, thus reducing runtime
errors due to data discrepancies.</li>
</ul>
<p>Consider the following illustrative protobuf definition:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode proto"><code class="sourceCode protobuf"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">// event.proto</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>syntax = <span class="st">&quot;proto3&quot;</span>;</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Namespace for this file</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> example;</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Type {</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    CREATED = <span class="dv">0</span>;</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Strongly-typed event. The numbered attributes of each field are used to</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co">// encode the field&#39;s position in the serialized message.</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span> Event {</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    Type id = <span class="dv">1</span>;</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">string</span> name = <span class="dv">2</span>;</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Schema evolution allows for new fields to be</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// added, while maintaining backwards compatibility</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">optional</span> <span class="dt">string</span> description = <span class="dv">3</span>; <span class="co">// New field added at a later revision</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This definition specifies an event data-type with specific
attributes. Central to processing this definition across different
languages is the <code>protoc</code> compiler. One of its standout
features is the extensible plugin architecture. As highlighted in
<strong>Chapter 1</strong>, plugins are pivotal in enhancing the
capabilities of software tools. With the aid of <a
href="https://github.com/protocolbuffers/protobuf/blob/main/docs/third_party.md">protoc
plugins</a>, developers not only have the flexibility to generate code
suitable for a wide array of programming languages, but they can also
craft their own plugins. An example is seen in QtGrpc, where a custom
plugin will translate the proto file to c++ classes, which seamlessly
integrate into the Qt ecosystem. Additionally, plugins like <a
href="https://github.com/pseudomuto/protoc-gen-doc">protoc-gen-doc</a>
extend the capability of <code>protoc</code> by offering the convenience
of producing documentation directly from inline comments within the
proto file.</p>
<figure>
<img src="./images/protobuf_protoc.png" alt="protoc extensions" />
<figcaption aria-hidden="true">protoc extensions</figcaption>
</figure>
<p>For instance, to compile the protobuf file into a Python interface,
use:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">protoc</span> <span class="at">--python_out</span><span class="op">=</span>./build event.proto</span></code></pre></div>
<p>The code outputted by protobuf may appear abstract as it doesn’t
directly provide methods for data access. Instead, it utilizes
metaclasses and descriptors. Think of descriptors as guiding the overall
behavior of a class with its attributes.</p>
<p>To further illustrate, here’s an integration with our generated
class:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># event.py</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> build.event_pb2 <span class="im">as</span> E</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> google.protobuf.json_format <span class="im">import</span> MessageToJson</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>event <span class="op">=</span> E.Event(<span class="bu">id</span><span class="op">=</span>E.Type.CREATED, name<span class="op">=</span><span class="st">&#39;test&#39;</span>, description<span class="op">=</span><span class="st">&#39;created event!&#39;</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_section(title, content):</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">:</span><span class="ch">\n</span><span class="sc">{</span><span class="st">&#39;-&#39;</span><span class="op">*</span><span class="bu">len</span>(title)<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>content<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>print_section(<span class="st">&quot;Python structure&quot;</span>, event)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>print_section(<span class="st">&quot;Serialized structure&quot;</span>, event.SerializeToString())</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>print_section(<span class="st">&quot;JSON structure&quot;</span>, MessageToJson(event))</span></code></pre></div>
<p>Executing this yields:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Python</span> structure:</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ex">----------------</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ex">id:</span> CREATED</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ex">name:</span> <span class="st">&quot;test&quot;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="ex">description:</span> <span class="st">&quot;created event!&quot;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Serialized</span> structure:</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="ex">--------------------</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="ex">b</span><span class="st">&#39;\x08\x01\x12\x04test&quot;\x0ecreated event!&#39;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="ex">JSON</span> structure:</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="ex">--------------</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a><span class="kw">{</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;id&quot;</span><span class="ex">:</span> <span class="st">&quot;CREATED&quot;</span>,</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;name&quot;</span><span class="ex">:</span> <span class="st">&quot;test&quot;</span>,</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;description&quot;</span><span class="ex">:</span> <span class="st">&quot;created event!&quot;</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>This demonstration highlights protobuf’s capabilities. It illustrates
the simplicity with which a type can be created, serialized into a
compact binary format, and its contents used by the application. The
benefits of protobuf’s efficiency become even more pronounced when
contrasted with heftier formats like JSON or XML.</p>
<h3 id="grpc-core-concepts">2.3.2 gRPC Core Concepts</h3>
<h4 id="channels">Channels</h4>
<p>in gRPC act as a conduit for client-side communication with a gRPC
service. A channel represents a session which, unlike HTTP/1.1, remains
open for multiple requests and responses.</p>
<h4 id="services">Services</h4>
<p>in gRPC define the methods available for remote calls. They’re
specified using the protobuf language and serve as API between the
server and its clients.</p>
<h4 id="stubs">Stubs</h4>
<p>are the client-side representation of a gRPC service. They provide
methods corresponding to the service methods defined in the .proto
files.</p>
<h4 id="calls-and-streams">Calls and Streams</h4>
<p>in gRPC provide the functionality for continuous data exchange
between the client and the server. The four primary RPC types are:</p>
<ol type="1">
<li>Unary Calls: This is the most common type, similar to a regular
function call where the client sends a single request and gets a single
response.</li>
<li>Server Streaming: The client sends a single request and receives
multiple responses. Useful when the server needs to push data
continuously after processing a client request.</li>
<li>Client Streaming: The client sends multiple requests before it
awaits the server’s single response. Useful in scenarios like file
uploads where the client has a stream of data to send.</li>
<li>Bidirectional Streaming: Both client and server send a sequence of
messages to each other. They can read and write in any order. This is
beneficial in real-time applications where both sides need to
continuously update each other.</li>
</ol>
<figure>
<img src="./images/grpc_abstract.svg" style="width:77.0%"
alt="gRPC high-level overview" />
<figcaption aria-hidden="true">gRPC high-level overview</figcaption>
</figure>
<h3 id="performance">2.3.3 Performance</h3>
<p>Traditional HTTP protocols don’t support sending multiple requests or
receiving multiple responses concurrently within a single connection.
Each request or response would necessitate a fresh connection.</p>
<p>However, with the advent of HTTP/2, this constraint was addressed.
The introduction of the binary framing layer in HTTP/2 enables such
request/response multiplexing. This ability to handle streaming
efficiently is a significant factor behind gRPC’s enhanced
performance.</p>
<figure id="fig:grpcbench">
<img src="./images/grpc_benchmarks.png"
alt="gRPC streaming benchmarks" />
<figcaption>Figure 4: gRPC streaming <a
href="https://grafana-dot-grpc-testing.appspot.com/d/18sWlbd7z/grpc-performance-multi-language-on-gke-atupstream-master?viewPanel=8">benchmarks</a></figcaption>
</figure>
<p>As depicted in <em>fig. 4</em>, the performance benchmarks highlight
the latencies associated with various gRPC clients when interfaced with
a C++ server implementation. The results reveal a spectrum of latencies,
with some as low as 100 microseconds (us) and others peaking around 350
us. Importantly, these tests measure the Round Trip Time (RTT),
representing the duration taken to send a message and subsequently
receive a response.</p>
<h2 id="the-qt-framework">2.3 The Qt Framework</h2>
<p><a href="https://www.qt.io/">Qt</a>, emerging in the early 90s from
Trolltech in Norway, stands out in the landscape of software development
for its robust toolkit that simplifies the creation of graphical user
interfaces (GUIs) that are platform-agnostic. With Qt, the same codebase
can be deployed on multiple operating systems such as Linux, Windows,
macOS, Android or embedded systems with little need for modification,
streamlining the development process significantly.</p>
<p>After its acquisition by Nokia in 2008, Qt has continued to thrive
under the guidance of The Qt Company, which is responsible for its
ongoing development and maintenance. Qt provides two licensing options:
the GNU (L)GPL license, promoting a community-driven approach, and a
commercial license for developers who prefer to maintain exclusive
control over their software.</p>
<p>Qt’s versatility extends beyond its C++ core, offering language
bindings for additional programming languages, with Python being a
notable example through <a href="https://doc.qt.io/qtforpython-6/">Qt
for Python / PySide6</a>. This extension facilitates rapid development
by allowing the integration of Qt’s powerful C++ modules within Python’s
flexible scripting environment.</p>
<h3 id="core-techniques">2.3.1 Core Techniques</h3>
<p>Central to Qt is its <a
href="https://doc.qt.io/qt-6/signalsandslots.html">Signals &amp;
Slots</a> mechanism, which can be thought of as a flexible
implementation of the observer pattern. A ‘signal’ represents an
observable event, while a ‘slot’ is comparable to an observer that can
react to that event. This design allows for a many-to-many relationship
meaning any signal may be connected to any number of slots. This concept
has been fundamental to Qt since its first release in 1994 and the
concept of signals and slots is so compelling that it has become a part
of the computer science landscape.</p>
<p>Essential for the reactive nature of graphical user interfaces,
signals &amp; slots enables a program to handle user-generated events
such as clicks and selections, as well as system-generated events like
incoming data transmissions. Qt employs the moc (Meta Object Compiler),
a tool developed within the Qt framework, which seamlessly integrates
these event notifications into Qt’s event loop.</p>
<p>Let’s examine a code example to understand the practicality and
simplicity of signals &amp; slots in Qt:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// signals_and_moc.cpp</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;QCoreApplication&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;QRandomGenerator&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;QTimer&gt;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;QDebug&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">// To use signals and slots, we must inherit from QObject.</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyObject <span class="op">:</span> <span class="kw">public</span> <span class="ex">QObject</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_OBJECT</span>  <span class="co">// Tell MOC to target this class</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    MyObject<span class="op">(</span><span class="ex">QObject</span> <span class="op">*</span>parent <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">:</span> <span class="ex">QObject</span><span class="op">(</span>parent<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> setData<span class="op">(</span>qsizetype data<span class="op">)</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>data <span class="op">==</span> mData<span class="op">)</span> <span class="op">{</span> <span class="co">// No change, don&#39;t emit signal</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>            <span class="fu">qDebug</span><span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;Rejected data: &quot;</span> <span class="op">&lt;&lt;</span> data<span class="op">;</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>        mData <span class="op">=</span> data<span class="op">;</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        <span class="ex">emit</span> dataChanged<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a><span class="ex">signals</span><span class="op">:</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dataChanged<span class="op">(</span>qsizetype data<span class="op">);</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    qsizetype mData<span class="op">;</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>In this code snippet, we create a class integrated with Qt’s <a
href="https://doc.qt.io/qt-6/metaobjects.html">Meta-Object System</a>.
To mesh with the Meta-Object System, three steps are critical:</p>
<ol type="1">
<li>Inherit from <code>QObject</code> to gain meta-object
capabilities.</li>
<li>Use the <code>Q_OBJECT</code> macro to enable the
<strong>MOC’s</strong> code generation.</li>
<li>Utilize the <code>moc</code> tool to generate the necessary
meta-object code, facilitating signal and slot functionality.</li>
</ol>
<p>The <code>MyObject</code> class emits the <code>dataChanged</code>
signal only when new data is set.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// signals_and_moc.cpp</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> receiveOnFunction<span class="op">(</span>qsizetype data<span class="op">)</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="fu">qDebug</span><span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;1. Received data on free function: &quot;</span> <span class="op">&lt;&lt;</span> data<span class="op">;</span> <span class="op">}</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyReceiver <span class="op">:</span> <span class="kw">public</span> <span class="ex">QObject</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_OBJECT</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="ex">slots</span><span class="op">:</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> receive<span class="op">(</span>qsizetype data<span class="op">)</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="fu">qDebug</span><span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;2. Received data on member function: &quot;</span> <span class="op">&lt;&lt;</span> data<span class="op">;</span> <span class="op">}</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">*</span> argv<span class="op">[])</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QCoreApplication</span> app<span class="op">(</span>argc<span class="op">,</span> argv<span class="op">);</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    MyObject obj<span class="op">;</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    MyReceiver receiver<span class="op">;</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QTimer</span> timer<span class="op">;</span> <span class="co">// A timer to periodically change the data</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    timer<span class="op">.</span>setInterval<span class="op">(</span><span class="dv">1000</span><span class="op">);</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QObject::connect</span><span class="op">(&amp;</span>timer<span class="op">,</span> <span class="op">&amp;</span><span class="ex">QTimer::timeout</span><span class="op">,</span> <span class="op">[&amp;</span>obj<span class="op">]()</span> <span class="op">{</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>        obj<span class="op">.</span>setData<span class="op">(</span><span class="ex">QRandomGenerator::global</span><span class="op">()-&gt;</span>bounded<span class="op">(</span><span class="dv">3</span><span class="op">));</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    timer<span class="op">.</span>start<span class="op">();</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Connect the signal to three different receivers.</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QObject::connect</span><span class="op">(&amp;</span>obj<span class="op">,</span> <span class="op">&amp;</span>MyObject<span class="op">::</span>dataChanged<span class="op">,</span> <span class="op">&amp;</span>receiveOnFunction<span class="op">);</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QObject::connect</span><span class="op">(&amp;</span>obj<span class="op">,</span> <span class="op">&amp;</span>MyObject<span class="op">::</span>dataChanged<span class="op">,</span> <span class="op">&amp;</span>receiver<span class="op">,</span> <span class="op">&amp;</span>MyReceiver<span class="op">::</span>receive<span class="op">);</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QObject::connect</span><span class="op">(&amp;</span>obj<span class="op">,</span> <span class="op">&amp;</span>MyObject<span class="op">::</span>dataChanged<span class="op">,</span> <span class="op">[](</span>qsizetype data<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>        <span class="fu">qDebug</span><span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;3. Received data on lambda function: &quot;</span> <span class="op">&lt;&lt;</span> data<span class="op">;</span></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Start the event loop, which handles all published events.</span></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ex">QCoreApplication::exec</span><span class="op">();</span></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The given code snippet demonstrates Qt’s signal and slot mechanism by
setting up a series of connections between a signal and various slot
types using <code>QObject::connect</code>. In a typical compilation
scenario for such a Qt application on a Linux system, you’d run a
command like:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ex">g++</span> <span class="at">-std</span><span class="op">=</span>c++17 <span class="at">-I</span>/usr/include/qt6 <span class="at">-I</span>/usr/include/qt6/QtCore <span class="at">-lQt6Core</span> <span class="at">-fPIC</span> <span class="at">-o</span> build/signals_and_moc signals_and_moc.cpp</span></code></pre></div>
<p>However, this direct approach to compile the file will be met with
linker errors, a sign that something is missing:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ex">/usr/bin/ld:</span> /tmp/ccbsQpDO.o: in function <span class="kw">`</span><span class="ex">main</span><span class="st">&#39;:</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="st">signals_and_moc.cpp:(.text+0x2e4): undefined reference to `MyObject::dataChanged(long long)&#39;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="ex">/usr/bin/ld:</span> /tmp/ccbsQpDO.o: in function <span class="kw">`</span>MyObject::MyObject<span class="er">(</span><span class="ex">QObject*</span><span class="kw">)</span><span class="st">&#39;:</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="st">signals_and_moc.cpp:(.text._ZN8MyObjectC2EP7QObject[_ZN8MyObjectC5EP7QObject]+0x26): undefined reference to `vtable for MyObject&#39;</span></span></code></pre></div>
<p>These errors indicate that we have a missing implementation for our
<code>dataChanged</code> function, which handles the signaling mechanism
of our object. This is where the meta-object-compiler comes into play
and provides the needed (boilerplate) implementation to this function.
The moc is integral to Qt’s signal and slot system, and without it, the
necessary meta-object code that facilitates these connections is not
generated. To correct the compilation process, moc must be run on the
source files containing the Q_OBJECT macro before the final compilation
step.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># assuming moc is in $PATH</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="ex">moc</span> signals_and_moc.cpp <span class="op">&gt;</span> gen.moc</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co"># include the generated file at the end of our source</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&#39;#include &quot;gen.moc&quot;&#39;</span> <span class="op">&gt;&gt;</span> signals_and_moc.cpp</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co"># re-compile</span></span></code></pre></div>
<p>A closer look at the output from moc uncovers the previously missing
pieces, providing the essential implementation for our
<code>dataChanged</code> signal and clarifying how moc underpins the
signal’s integration.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// SIGNAL 0</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> MyObject<span class="op">::</span>dataChanged<span class="op">(</span>qsizetype _t1<span class="op">)</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>_a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="kw">nullptr</span><span class="op">,</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> <span class="dt">void</span><span class="op">*&gt;(</span><span class="bu">std::</span>addressof<span class="op">(</span>_t1<span class="op">)))</span> <span class="op">};</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">QMetaObject::activate</span><span class="op">(</span><span class="kw">this</span><span class="op">,</span> <span class="op">&amp;</span><span class="fu">staticMetaObject</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> _a<span class="op">);</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>After running the corrected compilation and executing the
application, the output could look like this:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./build/signals_and_moc</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ex">1.</span> Received data on free function:  0</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2.</span> Received data on member function:  0</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="ex">3.</span> Received data on lambda function:  0</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="ex">Rejected</span> data:  0</span></code></pre></div>
<h3 id="graphics">2.3.2 Graphics</h3>
<p>Within the vast expanse of the Qt universe, developers are presented
with two primary paradigms for GUI crafting: Widgets and QML. Widgets
offer the traditional approach in creating UI elements, making it the
go-to for many classical desktop applications. Their imprint is evident
in widely-adopted applications like <a
href="https://github.com/telegramdesktop/tdesktop/blob/dev/Telegram/SourceFiles/mainwidget.cpp#L255">Telegram</a>
and <a
href="https://github.com/google/earthenterprise/blob/893f6b470673e2bad4cacdd8eec5ad1f179b6249/earth_enterprise/src/fusion/fusionui/main.cpp#L28">Google
Earth</a>.</p>
<p>Conversely, <strong>QML</strong> (Qt Modeling Language) represents a
contemporary, declarative approach to UI design. It employs a clear,
JSON-like syntax, while utilizing inline JavaScript for imperative
operations. Central to its design philosophy is dynamic object
interconnection, leaning heavily on property bindings. One of its
notable strengths is the seamless integration with C++, ensuring a clean
separation between application logic and view, without any significant
performance trade-offs.</p>
<p>Above the foundational QML module resides <strong>QtQuick</strong>,
the de facto standard library for crafting QML applications. While <a
href="https://doc.qt.io/qt-6/qtqml-index.html">Qt QML</a> lays down the
essential groundwork by offering the QML and JavaScript engines,
overseeing the core mechanics, QtQuick comes equipped with fundamental
types imperative for spawning user interfaces in QML. This library
furnishes the visual canvas and encompasses a suite of types tailored
for creating and animating visual components.</p>
<p>A significant distinction between Widgets and QML lies in their
rendering approach. Widgets, relying on software rendering, primarily
lean on the CPU for graphical undertakings. This sometimes prevents them
from harnessing the full graphical capabilities of a device. QML,
however, pivots this paradigm by capitalizing on the hardware GPU,
ensuring a more vibrant and efficient rendering experience. Its
declarative nature streamlines design interpretation and animation
implementation, ultimately enhancing the development velocity.</p>
<p><strong>Qt6</strong>, the most recent major release in the Qt series,
introduced a series of advancements. A standout among these is the QRHI
(Qt Rendering Hardware Interface). Functioning subtly in the background,
QRHI adeptly handles the complexities associated with graphic hardware.
Its primary mission is to guarantee determined performance consistency
across a diverse range of graphic backends. The introduction of <a
href="https://doc.qt.io/qt-6/qrhi.html">QRHI</a> underscores Qt’s
steadfast dedication to strengthen its robust cross-platform
capabilities, aiming to create a unified experience across various
graphic backends.</p>
<figure id="fig:qrhi">
<img src="./images/qt_rhi.png"
alt="Qt Rendering Hardware Interface RHI" />
<figcaption>Figure 5: Qt Rendering Hardware Interface <a
href="https://doc.qt.io/qt-6/topics-graphics.html">RHI</a></figcaption>
</figure>
<p><em>fig. 5</em> presents the layered architecture of the rendering
interface. At its base, it supports native graphic APIs such as OpenGL,
Vulkan or Metal. Positioned just above is the QWindows implementation,
which is housed within the QtGui module of Qt. Notably, QtWidgets
occupies a niche between these two levels. Given that Widgets emerged
before the QRhi module, their integration with QRhi isn’t as profound.
While certain widgets do offer OpenGL capabilities, their primary
reliance is on the <a
href="https://doc.qt.io/qt-6/qpainter.html#drawing">QPainter</a> API.
Ascending to the subsequent tier, we are greeted by the Qt Rendering
Hardware Interface, which serves as a crucial bridge, offering an
abstraction layer over hardware-accelerated graphics APIs.</p>
<blockquote>
<p><strong>Note:</strong> As of this writing, QRHI maintains a limited
compatibility assurance, implying potential shifts in its API. However,
such changes are anticipated to be minimal.</p>
</blockquote>
<p>Further up the hierarchy, the QtQuick and QtQuick3D modules showcase
Qt’s progression in graphics rendering.</p>
<p>In essence, Qt delivers a comprehensive framework for designing user
interfaces that cater to the diverse array of existing platforms. It
provides a broad spectrum of configuration and customization options and
even enabling developers to tap into lower-level abstractions for
crafting custom extensions tailored to specific project requirements—all
while preserving <em>cross-platform functionality</em>. Beyond the
foundational modules geared toward GUI development, Qt also offers a
rich suite of additional modules. These include resources for localizing
applications with <a
href="https://code.qt.io/cgit/qt/qttranslations.git/">qttranslations</a>,
handling audio and video via <a
href="https://code.qt.io/cgit/qt/qtmultimedia.git/">qtmultimedia</a>,
and various connectivity and networking options. Modules such as <a
href="https://code.qt.io/cgit/qt/qtconnectivity.git/">qtconnectivity</a>,
<a href="https://code.qt.io/cgit/qt/qtwebsockets.git/">qtwebsockets</a>,
and the latest addition, <a
href="https://code.qt.io/cgit/qt/qtgrpc.git/">qtgrpc</a>, facilitate the
integration of Qt into an even wider range of systems.</p>
<h3 id="qtgrpc-and-qtprotobuf">2.3.3 QtGrpc and QtProtobuf</h3>
<p>The <a href="https://doc.qt.io/qt-6/qtgrpc-index.html">QtGrpc</a>
module, which is in a technical preview stage as of Qt version 6.6,
represents an innovative addition to Qt’s suite. It provides plugins for
the <code>protoc</code> compiler, which we touched upon in section
<strong>3.2</strong>. These plugins are designed to serialize and
deserialize Protobuf messages into Qt-friendly classes, facilitating a
smooth and integrated experience within the Qt framework. This
integration significantly reduces the need for additional boilerplate
code when working with Protobuf and gRPC.</p>
<p>To enhance our previous <code>event.proto</code> definition with Qt
features, let’s compile it using the qtprotobufgen plugin as
follows:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># assuming qtprotobufgen is in $PATH</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="ex">protoc</span> <span class="at">--plugin</span><span class="op">=</span>protoc-gen-qtprotobuf=qtprotobufgen <span class="at">--qtprotobuf_out</span><span class="op">=</span>./build event.proto</span></code></pre></div>
<p>This command will generate the <code>build/event.qpb.h</code> and
<code>build/event.qpb.cpp</code> files. A review of the generated header
demonstrates how the plugin eases the integration of Protobuf
definitions within the Qt framework:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// build/event.qpb.h</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Event <span class="op">:</span> <span class="kw">public</span> QProtobufMessage</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_GADGET</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    Q_PROTOBUF_OBJECT</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    Q_DECLARE_PROTOBUF_SERIALIZERS<span class="op">(</span>Event<span class="op">)</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_PROPERTY</span><span class="op">(</span>example<span class="op">::</span>TypeGadget<span class="op">::</span>Type id_proto READ id_proto WRITE setId_proto SCRIPTABLE <span class="kw">true</span><span class="op">)</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_PROPERTY</span><span class="op">(</span><span class="ex">QString</span> name READ name WRITE setName SCRIPTABLE <span class="kw">true</span><span class="op">)</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_PROPERTY</span><span class="op">(</span><span class="ex">QString</span> description READ description_p WRITE setDescription_p<span class="op">)</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Q_PROPERTY</span><span class="op">(</span><span class="dt">bool</span> hasDescription READ hasDescription<span class="op">)</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> QtProtobufFieldEnum <span class="op">=</span> Event_QtProtobufNested<span class="op">::</span>QtProtobufFieldEnum<span class="op">;</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    Event<span class="op">();</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>Event<span class="op">();</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>In the provided C++ header file, the <code>Event</code> class
inherits from <code>QProtobufMessage</code> to leverage Qt’s meta-object
system for seamless serialization and deserialization of Protocol
Buffers. This class definition enables the automatic conversion of data
types defined in .proto files to Qt-friendly types. Such integration
allows developers to use these types with ease within both the Qt C++
environment and QML, facilitating rapid and adaptable integration with
gRPC services, irrespective of the server’s implementation language.</p>
<p>Furthermore, QtGrpc extends the functionality of Protocol Buffers
within the Qt framework by providing essential classes and tools for
gRPC communication. For example, <code>QGrpcHttp2Channel</code> offers
an <em>HTTP/2</em> channel implementation for server communication,
while <code>QGrpcCallReply</code> integrates incoming messages into the
Qt event system. This synergy between QtGrpc and protocol buffers
streamlines client-server interactions by embedding Protocol Buffer
serialization within Qt’s event-driven architecture.</p>
<h1 id="chapter-3-related-work">Chapter 3: Related Work</h1>
<ul>
<li><p>CLAP is relatively new</p></li>
<li><p>ClapPlugins / Clap Host by alexandre</p></li>
<li><p>JUCE</p></li>
</ul>
<h1 id="chapter-3-remote-plugins">Chapter 3: Remote Plugins</h1>
<h2 id="introduction">3.1 Introduction</h2>
<p>After the definition of the problem, and the introduction to the
tools that will be used, we focus on this section on describing the main
goal, which is to enable a native development experience, leaving aside
unflexible techniques as enforcing users to compile Qt in a seperate
namespace. Furthermore a stable user experience that works at least on
all available desktop platforms, is a hard requirement.</p>
<figure id="fig:plug_tradition">
<img src="./images/plugins_traditional.png"
alt="Traditional plugin architecture" />
<figcaption>Figure 6: Traditional plugin architecture</figcaption>
</figure>
<p><em>fig. 6</em> outlines traditional audio plugin architectures, when
used with graphical user interfaces. As we know, multiple instances will
be created out of our DSO, hence enforcing reentrancy. The traditional
approach is to start the event loop of the user interface inside a
dedicated thread, resulting in a minimum of 2 threads that ‘live’ inside
the DSO’s process. This technique can be seen in <a
href="https://juce.com/">JUCE</a>, a well-known library for creating
plugin-standard agnostic plugins, as well as in various other open
source implementation.</p>
<p>Due to the limitation that it’s not possible to start Qts event loop
inside a dedicated thread, we will simply execute the GUI plugin inside
a seperate process. Starting it inside a seperate process could be seen
as expensive or beeing slow and hard to incorporate because of the
various issues with IPC<a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>, but experimentation for this work
has shown that it’s equally as good. First of all, modern computers
should be able to handle an extra process with ease and secondly this
approach provides the implementation with a safety state.</p>
<p>As an example, let’s look at the case where we have the GUI and
realtime thread within the same process. A crash in the user interface
would then also crash the realtime thread. However when the GUI crashes,
launched as seperate process, the realtime thread wouldn’t notice it.
The implementation of IPC or RPC techniques is a bit more delicate and
indeed might result in additional implementation efforts. On the other
hand, the performance shouldn’t be affected critically by it. The
messages we have to share between audio and gui thread are very small in
size, as some parameter changes or note events; usually contain just a
few bytes in size. When thinking about sharing the audio data,
techniques such as opening shared memory pools could be employed in
order to make it equally as fast. Although, the cost will appear on the
difficulties when implementing it. It’s important to note that GUIs
don’t have to operate at the same speed of the realtime thread.</p>
<p>Luckily for us, humans perception of fluent and smooth visuals is
limited by the perception of our eyes. The critical flimmer fusion
frequency defines this as follows:</p>
<blockquote>
<p>The critical flicker fusion rate is defined as the rate at which
human perception cannot distinguish modulated light from a stable field.
This rate varies with intensity and contrast, with the fastest variation
in luminance one can detect at 50–90 Hz</p>
</blockquote>
<p>However recent studies show that humans can perceive artifacts of up
to 500 Hz<span class="citation"
data-cites="https://www.nature.com/articles/srep07861">[<strong>https://www.nature.com/articles/srep07861?</strong>]</span>.
Traditional refresh rates for desktop monitors ranges between 240 - 60
Hz which would translate to 4.1 - 16 ms. This sets the boundary for the
communication speed we have to minimally target with our host
application for a smooth user experience.</p>
<p>We will utilize the following techniques for integrating Qt GUIs into
the CLAP standard:</p>
<ol type="1">
<li>Write a native gRPC server that handles connecting clients and
handles all events to and from the client in a bidirectional
fashion.</li>
<li>Write a client implementation that implements the server’s API</li>
<li>Start the GUI as executable in a seperate process on the desktop and
connect to the server upon start.</li>
<li>Remote control the GUI from the host for things like showing and
hiding the GUI.</li>
<li>Optionally demand functionality from the host by a client.</li>
</ol>
<p>using this in combination with QtGrpc’s prooved successfull and
showed a reliable, fast and native experience on desktop platforms.</p>
<h2 id="remote-control-interface">3.2 Remote Control Interface</h2>
<p>In this section we will discuss the implementation for CLAP’s remote
control interface (RCI) that sits on-top of the CLAP API to provide a
thin plugin layer abstraction to handle all communication in the
background.</p>
<blockquote>
<p>Note: The code and techniques presented in the following sections are
a snapshot of the current state of development and may not be optimal.
Many aspects still remain to be improved although the core idea has been
proofed successfull already.</p>
</blockquote>
<p>To make the server efficiently handle multiple clients, we will
actually apply the same techniques as used in the <em>Q*Application</em>
objects that initially prevented us from easy integration and more
generally led to all of this research. As mentioned in the <a
href="#objective">objective</a>, static objects not only posess problems
but can also increase the overall architecture, and in this case even
performance, tremendously. As briefly mentioned in the <a
href="#debugging">clap-debugging</a> section, the host <em>can</em>
implement various plug-in hosting modes. These put another constrain on
this project as the server has to operate fluently in all of those. The
constraints for our server implementation is as followed:</p>
<ul>
<li>All plugins that are contained within a CLAP live withing the same
process address space. This allows us to share the server by re-using
its capabilities for multiple client and reducing the required
resources.</li>
<li>Every plugin is loaded into a seperate process. While this is the
most safe approach, it’s also the resource heviest. Here we can’t reuse
the server and need to create a seperate one for every plugin which
results in unused potential.</li>
</ul>
<p>By not using Qt’s event system, we gain more flexibility and resolve
the various problems in integrating it in a stable way. The approach at
this state seemed the most flexible, performant and stable solution. By
using gRPC we enable the language independent features of protobufs IDL,
and clients are free to implement the provided API by the server in
whatever way they like. The servers responsibillity is solely to pump
all events to its clients and integrate incoming events from them. This
would allow for things like controlling your plugin through a terminal
application or embedded devices. It just needs to support gRPC and a
client implementation for the API. Additionally we can easily link all
our dependencies statically against our library target to provide great
portabillity. Having a portable library is crucial, especially when it
comes to plugins which often demand extra care to be taken.</p>
<figure id="fig:claprciarch">
<img src="./images/clap-rci_arch.png" alt="CLAP-RCI Architecture" />
<figcaption>Figure 7: CLAP-RCI Architecture</figcaption>
</figure>
<p><em>fig. 7</em> represents the overall architecture of the resulting
server library. At the bottom we have a host that supports the
CLAP-interface. Just above is the CLAP api that the host will use to
control the plugin. The client will also utilize this api but here we
additionally include the CLAP-RCI wrapper library to provide all
necessary communication mechanism out of the box. Then we have a client
implementation of <em>CLAP-RCI</em>. Both communicate through the HTTP/2
protocol of gRPC. Then the client implementation can provide various
devices that utilize this implementation.</p>
<h3 id="server-implementation">3.2.1 Server Implementation</h3>
<p>When designing IPC mechanisms, there are two types of interaction
styles: synchronous and asynchronous. The synchronous communication is
regarded as a request/response interaction style, where we actively wait
for the response of the RPC. In an asynchronous communication style the
interaction is event driven to provide the flexibillity of customized
processing which can lead to better utilization of the underlying
hardware. <span class="citation"
data-cites="https://ceur-ws.org/Vol-2767/07-QuASoQ-2020.pdf">[<strong>https://ceur-ws.org/Vol-2767/07-QuASoQ-2020.pdf?</strong>
link this somehow]</span></p>
<p>At the foundation of gRPC C++ asynchronous API is the Completion
Queue. To state the docs:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// grpcpp/completion_queue.h</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">/// A completion queue implements a concurrent producer-consumer queue, with</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">/// two main API-exposed methods: </span><span class="an">\a</span><span class="co"> </span><span class="cv">Next</span><span class="co"> and </span><span class="an">\a</span><span class="co"> </span><span class="cv">AsyncNext</span><span class="co">. These</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="co">/// methods are the essential component of the gRPC C++ asynchronous API</span></span></code></pre></div>
<p>The gRPC C++ library provides three ways for creating a server:</p>
<ol type="1">
<li><strong>Synchronous API</strong>: The most straight forward way. All
event handling and synchronization is abstracted away to provide a
straightforward approach of implementing the server. Client call waits
for the server to respond</li>
<li><strong>Callback API</strong>: An abstraction to the asynchronous
API to provide a more straightforward solution to the complexities of
the asynchronous API. <a href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a></li>
<li><strong>Asynchronous API</strong>: The most complex but also most
flexible way of creating and managing RPC calls. Allows for full control
over its threading model for the cost of a more complex implementation.
E.g. RPC polling must be explicitly handled and lifetime management is
complicated.</li>
</ol>
<p>Since our way of using gRPC is already quite unique and differs from
traditional microservice architectures, and we’re in a constrained
environment the asynchronous API has been chosen to provide a more
flexible approach to our library design. From here the following code
flow will be used:</p>
<figure id="fig:claprcilifetime">
<img src="./images/clap-rci_sequence_diag.svg"
alt="Lifetime of CLAP-RCI" />
<figcaption>Figure 8: Lifetime of CLAP-RCI</figcaption>
</figure>
<p><em>fig. 8</em> goes through the lifetime cycle of the server. Upon
the first plugin creation the server will be created and started by the
static server controller . When a plugin instance now executes its GUI,
we will supply the needed command line arguments, as the servers address
and the plugin identifier along the way. The GUI process must then try
to connect to the server. The server side then handles the connecting
GUI client and starts its internal polling callback mechanism. With this
polling mechanism all events for every plugin that has active clients
will be polled and sent to all of the clients. It’s important to note
that even if not displayed in the figure above, the server handles
possibly multiple plugin instances, which again can hold multiple
clients per plugin instance. When the last client has disconnected and
all server-side-streams have been closed, the event polling will be
stopped. This was implemented to increase performance and reduce
resource usage when no client is connected. Finally, when the last
plugin got unloaded by the host and we’re about to unload the DSO, we
will stop the server.</p>
<p>To identify or ‘register’ a specific plugin instance to the context
of the static server handler, we use a hashing algorithm known as <a
href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash</a>. This is
needed, because the GUI that connects has to map to its respective
plugin instance. This hash value will then be supplied as command line
argument when executing the GUI and is also used as the <em>key</em>
value when inserting the plugin into a map.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// core/global.h</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co">// MurmurHash3</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Since (*this) is already unique in this process, all we really want to do is</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co">// propagate that uniqueness evenly across all the bits, so that we can use</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">// a subset of the bits while reducing collisions significantly.</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="kw">inline</span> <span class="bu">std::</span>uint64_t<span class="op"> </span>toHash<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>ptr<span class="op">)</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> h <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;(</span>ptr<span class="op">);</span> <span class="co">// </span><span class="al">NOLINT</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    h <span class="op">^=</span> h <span class="op">&gt;&gt;</span> <span class="dv">33</span><span class="op">;</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> <span class="bn">0xff51afd7ed558ccd</span><span class="op">;</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    h <span class="op">^=</span> h <span class="op">&gt;&gt;</span> <span class="dv">33</span><span class="op">;</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    h <span class="op">*=</span> <span class="bn">0xc4ceb9fe1a85ec53</span><span class="op">;</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> h <span class="op">^</span> <span class="op">(</span>h <span class="op">&gt;&gt;</span> <span class="dv">33</span><span class="op">);</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Furthermore, to provide a means of communication with the plugin
instances we bundle all communication logic inside the class
<code>SharedData</code>. The name may not be optimal and will probably
be changed to something like <em>Pipe</em> but the responsibillity
should be clear. This class contains the polling mechanism and the
non-blocking and wait free queues to exchange events with the plugin. We
create a <em>SharedData</em> instance for every plugin. A section of the
public API looks like the following:</p>
<div class="sourceCode" id="lst:shareddata"
data-description="SharedData API"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="lst:shareddata-1"><a href="#lst:shareddata-1" aria-hidden="true" tabindex="-1"></a><span class="co">// server/shareddata.h</span></span>
<span id="lst:shareddata-2"><a href="#lst:shareddata-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SharedData</span>
<span id="lst:shareddata-3"><a href="#lst:shareddata-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="lst:shareddata-4"><a href="#lst:shareddata-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="lst:shareddata-5"><a href="#lst:shareddata-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> SharedData<span class="op">(</span>CorePlugin <span class="op">*</span>plugin<span class="op">);</span></span>
<span id="lst:shareddata-6"><a href="#lst:shareddata-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst:shareddata-7"><a href="#lst:shareddata-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> addCorePlugin<span class="op">(</span>CorePlugin <span class="op">*</span>plugin<span class="op">);</span></span>
<span id="lst:shareddata-8"><a href="#lst:shareddata-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> addStream<span class="op">(</span>ServerEventStream <span class="op">*</span>stream<span class="op">);</span></span>
<span id="lst:shareddata-9"><a href="#lst:shareddata-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> removeStream<span class="op">(</span>ServerEventStream <span class="op">*</span>stream<span class="op">);</span></span>
<span id="lst:shareddata-10"><a href="#lst:shareddata-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst:shareddata-11"><a href="#lst:shareddata-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> blockingVerifyEvent<span class="op">(</span>Event e<span class="op">);</span></span>
<span id="lst:shareddata-12"><a href="#lst:shareddata-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> blockingPushClientEvent<span class="op">(</span>Event e<span class="op">);</span></span>
<span id="lst:shareddata-13"><a href="#lst:shareddata-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> pushClientParam<span class="op">(</span><span class="at">const</span> ClientParams <span class="op">&amp;</span>ev<span class="op">);</span></span>
<span id="lst:shareddata-14"><a href="#lst:shareddata-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst:shareddata-15"><a href="#lst:shareddata-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">&amp;</span>pluginToClientsQueue<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> mPluginProcessToClientsQueue<span class="op">;</span> <span class="op">}</span></span>
<span id="lst:shareddata-16"><a href="#lst:shareddata-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">&amp;</span>pluginMainToClientsQueue<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> mPluginMainToClientsQueue<span class="op">;</span> <span class="op">}</span></span>
<span id="lst:shareddata-17"><a href="#lst:shareddata-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">&amp;</span>clientsToPluginQueue<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> mClientsToPluginQueue<span class="op">;</span> <span class="op">}</span></span>
<span id="lst:shareddata-18"><a href="#lst:shareddata-18" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>A section of the constructor starting the server and setting up all
crucial information looks like the following:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// plugin/coreplugin.cpp</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> hc <span class="op">=</span> ServerCtrl<span class="op">::</span>instance<span class="op">().</span>addPlugin<span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>hc<span class="op">);</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    dPtr<span class="op">-&gt;</span>hashCore <span class="op">=</span> <span class="op">*</span>hc<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    logInfo<span class="op">();</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The shared data is used as a pipeline for this plugin instance</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to communicate with the server and its clients</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    dPtr<span class="op">-&gt;</span>sharedData <span class="op">=</span> ServerCtrl<span class="op">::</span>instance<span class="op">().</span>getSharedData<span class="op">(</span>dPtr<span class="op">-&gt;</span>hashCore<span class="op">);</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ServerCtrl<span class="op">::</span>instance<span class="op">().</span>start<span class="op">())</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        SPDLOG_INFO<span class="op">(</span><span class="st">&quot;Server Instance started&quot;</span><span class="op">);</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>ServerCtrl<span class="op">::</span>instance<span class="op">().</span>isRunning<span class="op">());</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>Here we first add the plugin to the static <code>ServerCtrl</code>,
which registers it with the hashing algorithm. We then obtain the
<code>SharedData</code> instance for further communication and start the
server if it hasn’t been started yet.</p>
<p>Now lets explore the internal gRPC server implementation a bit more.
As already mentioned we use the asynchronous API to provide the most
flexible solution. For the massive amount of code that is required to
implement the server, we will gain a lot of flexibillity and control
over the threading model.</p>
<blockquote>
<p>With great power comes great responsibillity.</p>
</blockquote>
<p>The following code snippet shows the server constructor and the
creation of the completion queues.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// server/server.cpp</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Specify the amount of cqs and threads to use</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    cqHandlers<span class="op">.</span>reserve<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    threads<span class="op">.</span>reserve<span class="op">(</span>cqHandlers<span class="op">.</span>capacity<span class="op">());</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create the server and completion queues; launch server</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span> <span class="co">// Simplified for brevity</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create handlers to manage the RPCs and distribute them across</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the completion queues.</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    cqHandlers<span class="op">[</span><span class="dv">0</span><span class="op">]-&gt;</span>create<span class="op">&lt;</span>ServerEventStream<span class="op">&gt;();</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    cqHandlers<span class="op">[</span><span class="dv">1</span><span class="op">]-&gt;</span>create<span class="op">&lt;</span>ClientEventCallHandler<span class="op">&gt;();</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    cqHandlers<span class="op">[</span><span class="dv">1</span><span class="op">]-&gt;</span>create<span class="op">&lt;</span>ClientParamCall<span class="op">&gt;();</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Distribute completion queues across threads</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    threads<span class="op">.</span>emplace_back<span class="op">(&amp;</span>CqEventHandler<span class="op">::</span>run<span class="op">,</span> cqHandlers<span class="op">[</span><span class="dv">0</span><span class="op">].</span>get<span class="op">());</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    threads<span class="op">.</span>emplace_back<span class="op">(&amp;</span>CqEventHandler<span class="op">::</span>run<span class="op">,</span> cqHandlers<span class="op">[</span><span class="dv">1</span><span class="op">].</span>get<span class="op">());</span></span></code></pre></div>
<p>In the code snippet above we can already see the power we gain by
using the async API. We can create multiple completion queues and
distribute them individually across threads. This allows us to have full
control over the threading model. We will attach the completion queue to
handle all server communication towards the clients at position
<code>0</code> and handle all client communication at position
<code>1</code>.</p>
<p>We have three individual <em>rpc-tag</em> handler:</p>
<ol type="1">
<li><code>ServerEventStream</code> is the outgoing stream from the
plugin instance to its clients.</li>
<li><code>ClientEventCallHandler</code> handles important gRPC unary
calls from the client.</li>
<li><code>ClientParamCall</code> also handles gRPC unary calls but
solely for parameter changes.</li>
</ol>
<p>We differentiate between the two types of calls, because the
parameter calls from the client have to be supplied directly to the
realtime audio thread. The event calls can be blocking and don’t have to
be handled in the realtime. In fact, we use them for critical events
that need a verification from the client in the gui creation
process.</p>
<p>The completion queues, as already mentioned, are FIFO queues which
operate with a tag system. The tag system is used to identify the type
of event that is being processed. We enqueue tags which correspond to a
specific instruction and receive them at a later point in time when the
gRPC system has decided to process them.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> CqEventHandler<span class="op">::</span>run<span class="op">()</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    state <span class="op">=</span> RUNNING<span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>rawTag <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> ok <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Block until the next event is available in the completion queue.</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>cq<span class="op">-&gt;</span>Next<span class="op">(&amp;</span>rawTag<span class="op">,</span> <span class="op">&amp;</span>ok<span class="op">))</span> <span class="op">{</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">*</span>tag <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>EventTag<span class="op">*&gt;(</span>rawTag<span class="op">);</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">-&gt;</span>process<span class="op">(</span>ok<span class="op">);</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>At its very core, the completion queue is a blocking call that waits
for the the next operation. We start them in a seperate thread inside
the constructor of the server and they will run until we decide to stop
them. The <code>Next</code> function returns a generic <code>void</code>
pointer, which correlates to the tag we have enqueued at a earlier point
in time. We then cast it back to the original type and call the process
function. The <code>EventTag</code> is the base class for all other tags
inside a completion queue. It provides a virtual <code>process</code>
function which will be handled by either the derived classes or the base
class itself. Extra care has been taken to keep those <em>tag</em>
implementations slim to avoid potential bottlenecks. For instance, a
segment from the <code>ServerEventStream</code> implementation looks
like the following:</p>
<div class="sourceCode" id="lst:sevstreamprocess"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="lst:sevstreamprocess-1"><a href="#lst:sevstreamprocess-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ServerEventStream<span class="op">::</span>process<span class="op">(</span><span class="dt">bool</span> ok<span class="op">)</span></span>
<span id="lst:sevstreamprocess-2"><a href="#lst:sevstreamprocess-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="lst:sevstreamprocess-3"><a href="#lst:sevstreamprocess-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>state<span class="op">)</span> <span class="op">{</span></span>
<span id="lst:sevstreamprocess-4"><a href="#lst:sevstreamprocess-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> CONNECT<span class="op">:</span> <span class="op">{</span></span>
<span id="lst:sevstreamprocess-5"><a href="#lst:sevstreamprocess-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>ok<span class="op">)</span></span>
<span id="lst:sevstreamprocess-6"><a href="#lst:sevstreamprocess-6" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> kill<span class="op">();</span></span>
<span id="lst:sevstreamprocess-7"><a href="#lst:sevstreamprocess-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Create a new instance to serve new clients</span></span>
<span id="lst:sevstreamprocess-8"><a href="#lst:sevstreamprocess-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// while we&#39;re processing this one.</span></span>
<span id="lst:sevstreamprocess-9"><a href="#lst:sevstreamprocess-9" aria-hidden="true" tabindex="-1"></a>            parent<span class="op">-&gt;</span>create<span class="op">&lt;</span>ServerEventStream<span class="op">&gt;();</span></span>
<span id="lst:sevstreamprocess-10"><a href="#lst:sevstreamprocess-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Try to connect the client. The client must provide a valid hash-id</span></span>
<span id="lst:sevstreamprocess-11"><a href="#lst:sevstreamprocess-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// of a plugin instance in the metadata to successfully connect.</span></span>
<span id="lst:sevstreamprocess-12"><a href="#lst:sevstreamprocess-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>connectClient<span class="op">())</span> <span class="op">{</span></span>
<span id="lst:sevstreamprocess-13"><a href="#lst:sevstreamprocess-13" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> FINISH<span class="op">;</span></span>
<span id="lst:sevstreamprocess-14"><a href="#lst:sevstreamprocess-14" aria-hidden="true" tabindex="-1"></a>                stream<span class="op">.</span>Finish<span class="op">({</span> grpc<span class="op">::</span>StatusCode<span class="op">::</span>UNAUTHENTICATED<span class="op">,</span></span>
<span id="lst:sevstreamprocess-15"><a href="#lst:sevstreamprocess-15" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;Couldn&#39;t authenticate client&quot;</span> <span class="op">},</span> toTag<span class="op">(</span><span class="kw">this</span><span class="op">));</span></span>
<span id="lst:sevstreamprocess-16"><a href="#lst:sevstreamprocess-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="lst:sevstreamprocess-17"><a href="#lst:sevstreamprocess-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst:sevstreamprocess-18"><a href="#lst:sevstreamprocess-18" aria-hidden="true" tabindex="-1"></a>            sharedData<span class="op">-&gt;</span>tryStartPolling<span class="op">())</span> <span class="op">{</span></span>
<span id="lst:sevstreamprocess-19"><a href="#lst:sevstreamprocess-19" aria-hidden="true" tabindex="-1"></a>                SPDLOG_INFO<span class="op">(</span><span class="st">&quot;Already polling events!&quot;</span><span class="op">);</span></span>
<span id="lst:sevstreamprocess-20"><a href="#lst:sevstreamprocess-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="lst:sevstreamprocess-21"><a href="#lst:sevstreamprocess-21" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> WRITE<span class="op">;</span></span>
<span id="lst:sevstreamprocess-22"><a href="#lst:sevstreamprocess-22" aria-hidden="true" tabindex="-1"></a>            SPDLOG_INFO<span class="op">(</span><span class="st">&quot;ServerEventStream new client @ </span><span class="sc">{}</span><span class="st"> connected&quot;</span><span class="op">,</span> toTag<span class="op">(</span><span class="kw">this</span><span class="op">));</span></span>
<span id="lst:sevstreamprocess-23"><a href="#lst:sevstreamprocess-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="lst:sevstreamprocess-24"><a href="#lst:sevstreamprocess-24" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>The code snippet above shows the state machine of the
<code>ServerEventStream</code>. This specific section gets executed when
new clients connect to the server. Hidden behind the
<code>connectClient()</code> function is the authentication process:</p>
<p>A client has to provide a valid hash-id of a plugin instance to
successfully connect. If the authentication fails, the stream will be
finished. Here we can also see how the tag based system works. When we
call <code>stream.Finish</code> we provide the tag with the
<code>toTag</code> function, which simply <code>reinterpret_cast</code>s
the <code>this</code> pointer to a <code>void</code> pointer. Because we
changed the state to <code>FINISH</code>, the next time the completion
queue processes this tag, it will call the <code>process</code> function
again, but in a updated state. Finally, when the client has successfully
connected, we start the polling mechanism to supply the events.</p>
<figure id="fig:claprcitrace">
<img src="./images/clap-rci_server_trace.png" alt="Server Trace" />
<figcaption>Figure 9: Server Trace</figcaption>
</figure>
<p><em>fig. 9</em> showcases a section of the tracing when the project
is compiled in debug mode. Here we simply print some debugging
information to visualize the flow of the server. It can get increasingly
difficult to debug the server, because the completion queues are running
in seperate threads, and multiple plugins with again multiple clients
can be connected at the same time. This ensures to keep the development
and debugging experiences sane and robust.</p>
<h3 id="event-handling-and-communication">3.3.2 Event Handling and
Communication</h3>
<p>One of the most important and complex aspects of this library is the
event handling. We have to ensure that the events are processed in a
timely manner, that we comply with the realtime constraints, that is,
serving the events in a deterministic and predictable way. We also have
to manage the lifetime of the incoming RPC calls, synchronize access to
the shared resources and if that’s not enough we also have to find a
technique to correctly invoke gRPC calls.</p>
<p>Let me elaborate the last point a bit more. The gRPC library provides
various methods to communicate with the underlying channels, like we
have seen with the <code>Finish</code> method to close a channel, we
also have <code>Read</code> or <code>Write</code> methods. These methods
are the public interface to effectively receive and write messages. The
tricky part is that for the asynchronous API, those calls have to be
enqueued into the completion queues manually. This means that we can’t
call them from the plugin directly multiple times to communicate with
our clients. We have to enqueue them with a tag and then wait for the
completion queue to process them to enqueue another one.</p>
<blockquote>
<p>Completion Queues can only have one pending operation per tag.</p>
</blockquote>
<p>Now this wouldn’t be such an issue if we would’ve only had a single
plugin instance that communicates with a single client, but since the
server supports <strong>N</strong> plugins with <strong>M</strong>
clients attached to it this approach doesn’t scale well, in fact it
doesn’t scale at all.</p>
<p>Now a good and efficient approach would be to centralize this event
distribution at a common place, to scan through all messages that are
enqueued from the plugin instances and then send them over to the
clients, all at once. This technique would dramatically increases our
quality of life. On the plugin side we don’t have to worry about all the
synchronization and threading issues. We register our plugin with the
server and retrieve the handle to the <code>SharedData</code> object.
Then we can just push all events to the FIFO queues contained inside the
SharedData and everything from there will be automatically handled by
the server.</p>
<p>For this to work, we need to implement the event polling mechanism.
Since I didn’t want to introduce another independent thread to handle
this mechanism and also avoid the overhead of thread switching and the
tricky synchronization issues, I decided to re-use the completion queues
for this task. The completion queues are already running and hosting
internal thread pools. They additionally contain the capability to
communicate with the clients channels. We have to enqueue our own custom
operation into the completion queue and let it handle the lifetime and
the next invocation for us. Luckily, the gRPC library provides a
somewhat lesser known feature for that, the <code>Alarm</code>
class.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// grpcpp/alarm.h</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Trigger an alarm instance on completion queue </span><span class="an">\a</span><span class="co"> </span><span class="cv">cq</span><span class="co"> at the specified time.</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Once the alarm expires (at </span><span class="an">\a</span><span class="co"> </span><span class="cv">deadline</span><span class="co">) or it&#39;s cancelled (see </span><span class="an">\a</span><span class="co"> </span><span class="cv">Cancel</span><span class="co">),</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// an event with tag </span><span class="an">\a</span><span class="co"> </span><span class="cv">tag</span><span class="co"> will be added to </span><span class="an">\a</span><span class="co"> </span><span class="cv">cq</span><span class="co">. If the alarm expired, the</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// event&#39;s success bit will be true, false otherwise (ie, upon cancellation).</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// USAGE </span><span class="al">NOTE</span><span class="co">: This is frequently used to inject arbitrary tags into \a cq by</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// setting an immediate deadline. Such usage allows synchronizing an external</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// event with an application&#39;s \a grpc::CompletionQueue::Next loop.</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> Set<span class="op">(</span>grpc<span class="op">::</span>CompletionQueue<span class="op">*</span> cq<span class="op">,</span> <span class="at">const</span> T<span class="op">&amp;</span> deadline<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> tag<span class="op">)</span></span></code></pre></div>
<p>As stated in the <em>usage note</em> section, this is exactly what we
need. We implemented the <code>CqEventHandler</code> class to abstract
and manage the completion queues for us. Here we store all pending
(active) tags:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// server/cqeventhandler.h</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>eventtag<span class="op">&gt;,</span> grpc<span class="op">::</span>alarm<span class="op">&gt;</span> pendingalarmtags<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>uint64_t<span class="op">,</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>eventtag<span class="op">&gt;&gt;</span> pendingtags<span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>The <code>pendintags</code> map stores all currently active streams
or calls for communication and the <code>pendinalarmtags</code> map
stores all currently active alarms. As already stated, our base class
for handling tags called <code>EventTag</code> is, despite it beeing a
base class for the other tag implementations, also capable to handle the
<code>process(bool ok)</code> callback:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// server/tags/eventtag.h</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> EventTag</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> FnType <span class="op">=</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span><span class="dt">bool</span><span class="op">)&gt;;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> process<span class="op">(</span><span class="dt">bool</span> ok<span class="op">);</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="dt">void</span> kill<span class="op">();</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    CqEventHandler <span class="op">*</span>parent <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    ClapInterface<span class="op">::</span>AsyncService <span class="op">*</span>service <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>FnType<span class="op">&gt;</span> func<span class="op">{};</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    Timestamp ts<span class="op">{};</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>The process function can be overriden by the derived classes as we
have seen for the <code>ServerEventStream</code> implementation, but by
default it will call the <code>func</code> member. With this approach we
can inject custom functions into our alarmtag-based-subsystem and is the
foundation for the event polling.</p>
<p>When the completion queue processes such an alarm tag it will invoke
the <code>process</code> function as for every tag, but here the default
implementation will be called:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// server/tags/eventtag.cpp</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> EventTag<span class="op">::</span>process<span class="op">(</span><span class="dt">bool</span> ok<span class="op">)</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>func<span class="op">)(</span>ok<span class="op">);</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    kill<span class="op">();</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We just invoke the function and then destroy the tag immediately. The
current implementation works with single-shot alarm tags and could be
potentially be a target for future optimizations. The crucial interface
to interact with this mechanism is inside the
<code>CqEventHandler</code> class:</p>
<div class="sourceCode" id="lst:cqenqueue"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="lst:cqenqueue-1"><a href="#lst:cqenqueue-1" aria-hidden="true" tabindex="-1"></a><span class="co">// server/cqeventhandler.cpp</span></span>
<span id="lst:cqenqueue-2"><a href="#lst:cqenqueue-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> CqEventHandler<span class="op">::</span>enqueueFn<span class="op">(</span>EventTag<span class="op">::</span>FnType <span class="op">&amp;&amp;</span>f<span class="op">,</span> <span class="bu">std::</span>uint64_t<span class="op"> </span>deferNs <span class="co">/*= 0*/</span><span class="op">)</span></span>
<span id="lst:cqenqueue-3"><a href="#lst:cqenqueue-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="lst:cqenqueue-4"><a href="#lst:cqenqueue-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> eventFn <span class="op">=</span> pendingAlarmTags<span class="op">.</span>try_emplace<span class="op">(</span></span>
<span id="lst:cqenqueue-5"><a href="#lst:cqenqueue-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>make_unique<span class="op">&lt;</span>EventTag<span class="op">&gt;(</span><span class="kw">this</span><span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>f<span class="op">)),</span></span>
<span id="lst:cqenqueue-6"><a href="#lst:cqenqueue-6" aria-hidden="true" tabindex="-1"></a>        grpc<span class="op">::</span>Alarm<span class="op">()</span></span>
<span id="lst:cqenqueue-7"><a href="#lst:cqenqueue-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="lst:cqenqueue-8"><a href="#lst:cqenqueue-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst:cqenqueue-9"><a href="#lst:cqenqueue-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>eventFn<span class="op">.</span>second<span class="op">)</span> <span class="op">{</span></span>
<span id="lst:cqenqueue-10"><a href="#lst:cqenqueue-10" aria-hidden="true" tabindex="-1"></a>        SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;Failed to enqueue AlarmTag&quot;</span><span class="op">);</span></span>
<span id="lst:cqenqueue-11"><a href="#lst:cqenqueue-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="lst:cqenqueue-12"><a href="#lst:cqenqueue-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst:cqenqueue-13"><a href="#lst:cqenqueue-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst:cqenqueue-14"><a href="#lst:cqenqueue-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>deferNs <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> <span class="co">// Execute the function immediately.</span></span>
<span id="lst:cqenqueue-15"><a href="#lst:cqenqueue-15" aria-hidden="true" tabindex="-1"></a>        eventFn<span class="op">.</span>first<span class="op">-&gt;</span>second<span class="op">.</span>Set<span class="op">(</span></span>
<span id="lst:cqenqueue-16"><a href="#lst:cqenqueue-16" aria-hidden="true" tabindex="-1"></a>            cq<span class="op">.</span>get<span class="op">(),</span> gpr_now<span class="op">(</span><span class="dt">gpr_clock_type</span><span class="op">::</span>GPR_CLOCK_REALTIME<span class="op">),</span> toTag<span class="op">(</span>eventFn<span class="op">.</span>first<span class="op">-&gt;</span>first<span class="op">.</span>get<span class="op">())</span></span>
<span id="lst:cqenqueue-17"><a href="#lst:cqenqueue-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="lst:cqenqueue-18"><a href="#lst:cqenqueue-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="co">// Otherwise, defer the function. Note that this is using a syscall</span></span>
<span id="lst:cqenqueue-19"><a href="#lst:cqenqueue-19" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> tp <span class="op">=</span> gpr_time_from_nanos<span class="op">(</span>deferNs<span class="op">,</span> GPR_TIMESPAN<span class="op">);</span></span>
<span id="lst:cqenqueue-20"><a href="#lst:cqenqueue-20" aria-hidden="true" tabindex="-1"></a>        eventFn<span class="op">.</span>first<span class="op">-&gt;</span>second<span class="op">.</span>Set<span class="op">(</span>cq<span class="op">.</span>get<span class="op">(),</span> tp<span class="op">,</span> toTag<span class="op">(</span>eventFn<span class="op">.</span>first<span class="op">-&gt;</span>first<span class="op">.</span>get<span class="op">()));</span></span>
<span id="lst:cqenqueue-21"><a href="#lst:cqenqueue-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="lst:cqenqueue-22"><a href="#lst:cqenqueue-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="lst:cqenqueue-23"><a href="#lst:cqenqueue-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="lst:cqenqueue-24"><a href="#lst:cqenqueue-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>enqueueFn</code> function takes the callable function
<code>f</code> as first parameter and an optional second parameter for
the time, the call should be deferred. We first emplace the EventTag and
Alarm objects into the map. We store those tags because when the
desctructor of the <code>grpc::Alarm</code> object is beeing invoked, it
would call the <code>Cancel</code> function which would in return
immediately enqueue it inside the completion queue which is <em>not</em>
what we want. The completion queue should handle the correct invocation
for us and we only want to cancel tags manually when we shutdown the
server. Then we either defer the call or execute it immediately.</p>
<p>With this approach we can safely integrate the events from the plugin
instances to the corresponding completion queue handlers, and
furthermore provide a scallable and realiable solution to interact with
the gRPC interface from external threads.</p>
<p>Now lets explore the core mechanism that runs behind the scenes and
is responsible for the communication with the clients, the polling
mechanism. As already seen at
lst. <strong>¿lst:evstreamprocess?</strong>, upon successfull connection
we invoke the <code>tryStartPolling</code> function. The definition of
this function looks like the following:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> SharedData<span class="op">::</span>tryStartPolling<span class="op">()</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>isValid<span class="op">()</span> <span class="op">||</span> pollRunning<span class="op">)</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span> <span class="co">// Simplified for brevity</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    pollRunning <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    mServerStreamCq<span class="op">-&gt;</span>enqueueFn<span class="op">([</span><span class="kw">this</span><span class="op">](</span><span class="dt">bool</span> ok<span class="op">){</span> <span class="kw">this</span><span class="op">-&gt;</span>pollCallback<span class="op">(</span>ok<span class="op">);</span> <span class="op">},</span> mPollFreqNs<span class="op">);</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If the callback is already running we return false. Otherwise we will
start it by enqueueing the <code>pollCallback</code> function to the
function mentioned earlier at lst. <strong>¿lst:cqenqueue?</strong>. The
default polling frequency for <code>mPollFreqNs</code> is
<strong>5’000</strong> nanoseconds, which translates to
<strong>5</strong> microseconds. Which means that every 5 microseconds
we will re-enter the function and check for new events.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> SharedData<span class="op">::</span>pollCallback<span class="op">(</span><span class="dt">bool</span> ok<span class="op">)</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">~~~</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>streams<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>        SPDLOG_INFO<span class="op">(</span><span class="st">&quot;No streams connected. Stop polling.&quot;</span><span class="op">);</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> endCallback<span class="op">();</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">~~~</span></span></code></pre></div>
<p>To ensure that we don’t poll for events when there are no clients
connected, we automatically stop the polling mechanism. When clients
disconnect, either by themself or by the server, the
<code>streams</code> container will be updated.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Consume events from the queues</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> nProcessEvs <span class="op">=</span> consumeEventToStream<span class="op">(</span>mPluginProcessToClientsQueue<span class="op">);</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> nMainEvs <span class="op">=</span> consumeEventToStream<span class="op">(</span>mPluginMainToClientsQueue<span class="op">);</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nProcessEvs <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nMainEvs <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We have no events to send, so we can just enqueue the next callback with an increased backoff.</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        mServerStreamCq<span class="op">-&gt;</span>enqueueFn<span class="op">([</span><span class="kw">this</span><span class="op">](</span><span class="dt">bool</span> ok<span class="op">){</span> <span class="kw">this</span><span class="op">-&gt;</span>pollCallback<span class="op">(</span>ok<span class="op">);</span> <span class="op">},</span> nextExpBackoff<span class="op">());</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>Then, if the initial checks were successfull, we iterate over all
plugin instances and consume their events. The
<code>consumeEventToStream</code> function will process the CLAP
specific events and translate them into gRPC messages. We’ve split the
event-container into two queues, one for the realtime thread and one for
the main thread. This is due to the strict realtime constraints that we
have to comply with. The queues are preallocated and have a fixed size.
Since they are wait free, they internally override old messages when the
queue is full. This is a tradeoff that we have to take, because we can’t
block on the realtime thread. When there are no events to send, we will
enqueue the next callback with an increased exponential backoff. This is
to reduce the amount of CPU cycles that the server consumes when there
are no events to send.</p>
<figure id="fig:expbackoff">
<img src="./images/clap-rci_exp_backoff.png"
alt="Exponentiall Backoff" />
<figcaption>Figure 10: Exponentiall Backoff</figcaption>
</figure>
<p><em>fig. 10</em> shows the graph of the exponential backoff. This is
roughly the visualization of the function that we use to calculate the
next backoff. It is devided into three sections:</p>
<ol type="1">
<li>To the left, in red, is the section involved with high occurences of
events. This means one or multiple plugins are actively in use. The
events are processed as fast as possible.</li>
<li>In the middle, in orange, means that the previous section has
finished and is ‘cooling down’ or we have a medium destribution of
events.</li>
<li>To the right, in green, means that there are no events to send and
we can increase the backoff to reduce the CPU cycles that the server
consumes.</li>
</ol>
<p>Any event will reset the backoff to the initial value (in the red
section) again. This aligns mostly with the real-world use case.
Typically you would adjust some parameters or receive some notes from
the host. This would result in a high amount of events and would command
the polling callback to operate at full speed. When the user stops
actively using any plugins we go into <strong>stand-by</strong>
mode.</p>
<figure id="fig:expbackofftrace">
<img src="./images/clap-rci_exp_backoff_trace.png"
alt="Exponentiall Backoff Server Trace" />
<figcaption>Figure 11: Exponentiall Backoff Server Trace</figcaption>
</figure>
<p><em>fig. 11</em> shows this behavior. Here we added a additional
trace message to the previous code section. We’ve increased the
boundaries to highlight the behavior of the exponential backoff. We can
see that on the moment we receive a event, the backoff is reset to it’s
default value and then quickly increases again.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we reached this point, we have events to send.</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> success <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> stream <span class="op">:</span> streams<span class="op">)</span> <span class="op">{</span> <span class="co">// For all streams/clients</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>stream<span class="op">-&gt;</span>sendEvents<span class="op">(</span>mPluginToClientsData<span class="op">))</span> <span class="co">// try to pump some events.</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>            success <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~</span> <span class="op">}</span> <span class="co">// Simplified for brevity</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Succefully completed a round. Enqueue the next callback with</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// regular poll-frequency and reset the backoff.</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>    mPluginToClientsData<span class="op">.</span>Clear<span class="op">();</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    mCurrExpBackoff <span class="op">=</span> mPollFreqNs<span class="op">;</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>    mServerStreamCq<span class="op">-&gt;</span>enqueueFn<span class="op">([</span><span class="kw">this</span><span class="op">](</span><span class="dt">bool</span> ok<span class="op">){</span> <span class="kw">this</span><span class="op">-&gt;</span>pollCallback<span class="op">(</span>ok<span class="op">);</span> <span class="op">},</span> mPollFreqNs<span class="op">);</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>    SPDLOG_TRACE<span class="op">(</span><span class="st">&quot;PollCallback has sent: </span><span class="sc">{}</span><span class="st"> Process Events and </span><span class="sc">{}</span><span class="st"> Main Events&quot;</span><span class="op">,</span> nProcessEvs<span class="op">,</span> nMainEvs<span class="op">);</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="op">~~</span></span></code></pre></div>
<p>This final section shows the actual sending of the events. We iterate
over all connected streams (the <code>ServerEventStream</code>s) and try
to send the events. Finally, if everything was successfull, we enqueue
the next callback with the default poll frequency.</p>
<h3 id="clap-api-abstraction">3.2.3 CLAP API Abstraction</h3>
<p>In the previous section, we’ve already seen how the server resembles
and how the inidividual core components interact with eachother.
Additionally with the knowledge gained from the <a
href="#the_clap_audio_plugin_standard">CLAP</a> section, we know that
the CLAP standard provides an extension based interface for the plugin,
to provide its own custom functionality. We will focus here on the
relevant sections for the communication between the server and the
plugin and avoid the implementation details. The provided API
abstraction utilizes the <a
href="https://github.com/free-audio/clap-helpers">clap-helpers</a>,
toolkit provided by the CLAP team. It is a collection of various tools
to simplify the development. One of them is the <code>Plugin</code>
class, which sits inbetween the C-API and the context specific plugin
instances. It provides a thin abstraction layer utilizing trampoline
functions to forward the calls to the plugin instance.</p>
<p>The <code>CorePlugin</code> class is utilized to provide a generic
default implementation, with the server specific functionality included.
Users of this class can then override specific functions of the virtual
interface to customize its functionality.</p>
<p>We use two independent communication channels with the client’s GUI.
One is the non blocking channel, which is used for time critical
interaction. Here we enqueue the Events in a UDP<a href="#fn11"
class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
like fashion with a <em>fire and forget</em> approach. There is no point
in waiting for the client to receive the message. The events received
from the host inside the process callback deliver a snapshot of the
current representation of it’s value. They are often frequently updated
and given the high frequency the process callback operates in we can’t
afford to wait for the client response.</p>
<p>There are cases however, where we need to wait for the client
response. One of them is the GUI extension. Since our approach of
integrating the GUI is to start it as a seperate process, we will face
additional synchronization issues. The general idea unfolds as:</p>
<ol type="1">
<li>Provide the parameters hashed id of the plugin instance together
with the server address to the GUI</li>
<li>Execute the GUI executable with platform specific APIs</li>
<li>The GUI connects to the server and verifies the hash id</li>
<li>For every subsequent gui event from the host, as to show or hide the
GUI, we have to wait for the client response</li>
</ol>
<blockquote>
<p>Note: The CLAP specification doesn’t enforce a strict design and
provides some freedom to the host application. Some hosts may choose to
destroy the gui after every hide event of the plugin inside their UI,
while some other hosts may choose to keep the GUI alive and just hide
it.</p>
</blockquote>
<p>Special care has therefore been taken to ensure that the GUI creation
process can handle those cases. The public interface for those methods
are defined as followed:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">// coreplugin.h</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// #### GUI ####</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> implementsGui<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> guiIsApiSupported<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>api<span class="op">,</span> <span class="dt">bool</span> isFloating<span class="op">)</span> <span class="kw">noexcept</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> isFloating<span class="op">;</span> <span class="op">};</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> guiCreate<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>api<span class="op">,</span> <span class="dt">bool</span> isFloating<span class="op">)</span> <span class="kw">noexcept</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> guiSetTransient<span class="op">(</span><span class="at">const</span> clap_window <span class="op">*</span>window<span class="op">)</span> <span class="kw">noexcept</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> guiShow<span class="op">()</span> <span class="kw">noexcept</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> guiHide<span class="op">()</span> <span class="kw">noexcept</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> guiDestroy<span class="op">()</span> <span class="kw">noexcept</span> <span class="kw">override</span><span class="op">;</span></span></code></pre></div>
<p>Every extension can be controlled with the
<code>bool implements&lt;ext&gt;()</code> function. When an user would
return false in an override of his subclassed instance this extension
would be disabled, and thus also be ignored by the host application. In
the GUI creation we have to synchronize ourself with the client in order
to ensure that the GUI creation and verification succeeded.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> CorePlugin<span class="op">::</span>guiCreate<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>api<span class="op">,</span> <span class="dt">bool</span> isFloating<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>ServerCtrl<span class="op">::</span>instance<span class="op">().</span>isRunning<span class="op">())</span> <span class="op">{</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;Server is not running&quot;</span><span class="op">);</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>dPtr<span class="op">-&gt;</span>guiProc<span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>        SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;Gui Proc must be null upon gui creation&quot;</span><span class="op">);</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    dPtr<span class="op">-&gt;</span>guiProc <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>ProcessHandle<span class="op">&gt;();</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span> <span class="co">// other checks simplified for brevity</span></span></code></pre></div>
<p>Upon entering the default implementation of the
<code>guiCreate</code> function we first perform various sanity checks,
to verify that we can safely execute the GUI. We then create a new
<code>ProcessHandle</code> object, which is a wrapper around the
platform specific process APIs. We have to provide platform specific
implementations here since the C++ standard doesn’t have any notion of a
<em>process</em>. There this class provides a unified interface to
interact with the platform specific process APIs. On windows we use the
<code>CreateProcess</code> API from the <code>Kernel32.dll</code>
library. For linux and mac we use a POSIX compliant implementation. A
section of the public interface looks like the following:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if defined _WIN32 || defined _WIN64</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Windows.h&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> PidType <span class="op">=</span> DWORD<span class="op">;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#elif defined </span><span class="ot">__linux__</span><span class="pp"> || defined __APPLE__</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> PidType <span class="op">=</span> <span class="dt">pid_t</span><span class="op">;</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span> <span class="co">// Only Windows and Unix supported for now</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ProcessHandle</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    ProcessHandle<span class="op">();</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isChildRunning<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> waitForChild<span class="op">();</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> startChild<span class="op">();</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> terminateChild<span class="op">();</span></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>ProcessHandlePrivate<span class="op">&gt;</span> dPtr<span class="op">;</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This interface will then be used to start the GUI executable,
terminate or wait for it to finish. We use it like the following inside
the <code>guiCreate</code> function:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">// coreplugin.cpp &gt; guiCreate(~) {</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Send the hash as argument to identify the plugin to this instance.</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> shash <span class="op">=</span> <span class="bu">std::</span>to_string<span class="op">(</span>dPtr<span class="op">-&gt;</span>hashCore<span class="op">);</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>dPtr<span class="op">-&gt;</span>guiProc<span class="op">-&gt;</span>setArguments<span class="op">({</span> <span class="op">*</span>addr<span class="op">,</span> shash <span class="op">}))</span> <span class="op">{</span> <span class="co">// Prepare to launch the GUI</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>        SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;Failed to set args for executable&quot;</span><span class="op">);</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>dPtr<span class="op">-&gt;</span>guiProc<span class="op">-&gt;</span>startChild<span class="op">())</span> <span class="op">{</span>  <span class="co">// Start the GUI</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>        SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;Failed to execute GUI&quot;</span><span class="op">);</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span></code></pre></div>
<p>As briefly mentioned in the <a href="#server_implementation">server
implementation</a> section earlies we use a hashing algorithm to
identify the plugin instance. This hash will be provided as argument to
the executable and <em>must</em> be handled by the client and also
provided when starting communication.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="op">~~~</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    pushToMainQueueBlocking<span class="op">({</span>Event<span class="op">::</span>GuiCreate<span class="op">,</span> ClapEventMainSyncWrapper<span class="op">{}});</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>dPtr<span class="op">-&gt;</span>sharedData<span class="op">-&gt;</span>blockingVerifyEvent<span class="op">(</span>Event<span class="op">::</span>GuiCreate<span class="op">))</span> <span class="op">{</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>        SPDLOG_WARN<span class="op">(</span><span class="st">&quot;GUI has failed to verify in time. Killing Gui process.&quot;</span><span class="op">);</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>dPtr<span class="op">-&gt;</span>guiProc<span class="op">-&gt;</span>terminateChild<span class="op">())</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>            SPDLOG_CRITICAL<span class="op">(</span><span class="st">&quot;GUI proc failed to killChild&quot;</span><span class="op">);</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    enqueueAuxiliaries<span class="op">();</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We then push the <code>Event::GuiCreate</code> event to the main
queue and wait for the client to respond. If the client doesn’t respond
in time we will terminate the process and signal the failure. Otherwise
we can continue the the GUI creation process. A host would now provide a
system-window handle to the plugin instance. GUI plugins must integrate
this window handle by <strong>re-parenting</strong> themselves with this
window. This is a common technique to integrate GUIs into other
applications, by providing the context for the GUI to be created in:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> CorePlugin<span class="op">::</span>guiSetTransient<span class="op">(</span><span class="at">const</span> clap_window <span class="op">*</span>window<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>dPtr<span class="op">-&gt;</span>sharedData<span class="op">-&gt;</span>isPolling<span class="op">());</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>window<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>       SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;clap_window is null&quot;</span><span class="op">);</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    pushToMainQueueBlocking<span class="op">(</span> <span class="op">{</span>Event<span class="op">::</span>GuiSetTransient<span class="op">,</span> ClapEventMainSyncWrapper<span class="op">{</span> wid <span class="op">}</span> <span class="op">});</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>dPtr<span class="op">-&gt;</span>sharedData<span class="op">-&gt;</span>blockingVerifyEvent<span class="op">(</span>Event<span class="op">::</span>GuiSetTransient<span class="op">))</span> <span class="op">{</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>        SPDLOG_ERROR<span class="op">(</span><span class="st">&quot;GuiSetTransient failed to get verification from client&quot;</span><span class="op">);</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A simplified implementation of the <code>guiSetTransient</code> shows
the same patterns as the <code>guiCreate</code> function. When we look
at the non-blocking communications of the event handling we can see a
much simpler implementation:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> CorePlugin<span class="op">::</span>processEvent<span class="op">(~~~)</span> <span class="kw">noexcept</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>evHdr<span class="op">-&gt;</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CLAP_EVENT_PARAM_VALUE<span class="op">:</span> <span class="op">{</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> <span class="op">*</span>evParam <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> clap_event_param_value <span class="op">*&gt;(</span>evHdr<span class="op">);</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>        param<span class="op">-&gt;</span>setValue<span class="op">(</span>evParam<span class="op">-&gt;</span>value<span class="op">);</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>        pushToProcessQueue<span class="op">({</span> Event<span class="op">::</span>Param<span class="op">,</span> ClapEventParamWrapper<span class="op">(</span>evParam<span class="op">)</span> <span class="op">});</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> CLAP_EVENT_NOTE_ON<span class="op">:</span> <span class="op">{</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="kw">auto</span> <span class="op">*</span>evNote <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> clap_event_note <span class="op">*&gt;(</span>evHdr<span class="op">);</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>        pushToProcessQueue<span class="op">({</span> Event<span class="op">::</span>Note<span class="op">,</span> ClapEventNoteWrapper <span class="op">{</span> evNote<span class="op">,</span> CLAP_EVENT_NOTE_ON <span class="op">}});</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> <span class="op">~~~</span> <span class="op">}</span></span></code></pre></div>
<p>In this simplified example we can see that we only have to enqueue
the event as received from the host. And move-construct it insidethe
corresponding wrapper function. This wrapper classes ensure that the
event can be properly serialized and deserialized by the gRPC library,
while also providing a convenient conversions to and from the CLAP
C-API. Some other implementation can therefore be extremely simple using
this approach:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> CorePlugin<span class="op">::</span>deactivate<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    dPtr<span class="op">-&gt;</span>rootModule<span class="op">-&gt;</span>deactivate<span class="op">();</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    pushToMainQueue<span class="op">({</span>Event<span class="op">::</span>PluginDeactivate<span class="op">,</span> ClapEventMainSyncWrapper<span class="op">{}});</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> CorePlugin<span class="op">::</span>startProcessing<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    dPtr<span class="op">-&gt;</span>rootModule<span class="op">-&gt;</span>startProcessing<span class="op">();</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    pushToMainQueue<span class="op">({</span>Event<span class="op">::</span>PluginStartProcessing<span class="op">,</span> ClapEventMainSyncWrapper<span class="op">{}});</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>These functions only contain two lines of code. The first line calls
the rootModule, which is the “audio processing” module of the plugin
that implements this interface and contains the actual DSP logic. The
next line pushes the event to the queue to be processed by the
server.</p>
<h3 id="server-api">3.2.4 Server API</h3>
<p>The resulting library presented up to this point is the foundation
for potential users of it to build their project upon. However, when a
user would want to utilize the full potential of this library he would
also need a client that implements the public API, that the server
provides. To harness the full potential of gRPC and their language
independent protobuf interface, users of this library would need a
client implementation of the server’s interface to receive any events
and integrate them into their plugin and GUI creation process. For that,
the api is available in the <code>api/v0/api.proto</code> file and
includes the crucial interface for the gRPC communication. Similar to
how CLAP is structuring their events, with a header indicating the
payload, the protobuf uses a similar behavior:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode proto"><code class="sourceCode protobuf"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Event {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  PluginActivate                 = <span class="dv">0</span>;</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// { ~~~ }</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  GuiCreate                      = <span class="dv">26</span>;</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  GuiSetTransient                = <span class="dv">27</span>;</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  GuiShow                        = <span class="dv">28</span>;</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// { ~~~ }</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>  Param                          = <span class="dv">31</span>;</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>  ParamInfo                      = <span class="dv">32</span>;</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// { ~~~ }</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>  EventFailed                    = <span class="dv">42</span>;</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>  EventInvalid                   = <span class="dv">43</span>;</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>Event</code> enum indicates the type of event that is
currently received and must be sent by the host in order to guarantee a
correct communication. We can see that for the <code>ServerEvent</code>
message, which is the foundational message for outgoing streams from the
plugin to theirs clients:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode proto"><code class="sourceCode protobuf"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Plugin -&gt; Clients</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span> ServerEvent {</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  Event event = <span class="dv">1</span>;</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  oneof payload {</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    ClapEventNote note = <span class="dv">2</span>;</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    ClapEventParam param = <span class="dv">3</span>;</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    ClapEventParamInfo param_info = <span class="dv">4</span>;</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    ClapEventMainSync main_sync = <span class="dv">5</span>;</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here we utilize the <code>Event</code> type to indicate the message
type. Then we use the <code>oneof</code> protobuf keyword, since a
message can only contain one payload. The <code>oneof</code> specifier
can be thought of as a union type or <code>std::variant</code> in modern
C++. The <code>event</code> field could be thought to be superfluous,
since we could also check the payload type to determine the event type.
However, this approach provides a more robust and faster way to
determine the event type, and additionally provides better flexibility
for future extensions. The server at the moment only supports a subset
of the CLAP specification and can only provide note, parameter, and some
information events. In order to optimize the usage of the HTTP/2
protocol in combination with the server streaming, we bundle multiple
events into a single message:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode proto"><code class="sourceCode protobuf"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span> ServerEvents {</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">repeated</span> ServerEvent events = <span class="dv">1</span>;</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>In combination with the event polling machnisem presented earlier.
Which operates at a fixed maximum frequency, we can bundle multiple
events into a single message. The <code>repeated</code> keyword is
utilized for that. A specific event payload can be seen for the
<code>ClapEventParam</code> message:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode proto"><code class="sourceCode protobuf"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">message</span> ClapEventParam {</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">enum</span> Type {</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    Value = <span class="dv">0</span>;</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    Modulation = <span class="dv">1</span>;</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    GestureBegin = <span class="dv">2</span>;</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    GestureEnd = <span class="dv">3</span>;</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>  Type type = <span class="dv">1</span>;</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uint32</span> param_id = <span class="dv">2</span>;</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> value = <span class="dv">3</span>;</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> modulation = <span class="dv">4</span>;</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>This message type wraps the CLAP specific parameter events. A
parameter can have four different states:</p>
<ul>
<li><code>Type::Value</code> indicates a regular parameter update. This
happens when the user moves a knob or slider in their GUI or inside the
Hosts GUI.</li>
<li><code>Type::Modulation</code> is received when the parameter is
modulated with external modifiers as for example LFOs<a href="#fn12"
class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>
or other modulation sources.</li>
<li><code>Type::GestureBegin</code> and <code>Type::GestureEnd</code>
will usually be sent by the plugins GUI implementation to indicate the
manual interaction with the parameter. This can then be used to
improveLFO the audio rendering.</li>
</ul>
<p>These messages will then be serialized into a binary protobuf message
and assure fast and reliable communication between the server and the
clients. Finally, lets have a look at the defined service. While we’ve
presented all the individual messages, gRPC uses the service definition
to generate the actual API. The current provided API looks like the
following:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode proto"><code class="sourceCode protobuf"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>service ClapInterface {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  rpc ServerEventStream(ClientRequest) returns (stream ServerEvents) {}</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  rpc ClientEventCall(ClientEvent) returns (None) {}</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  rpc ClientParamCall(ClientParams) returns (None) {}</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Currently there are three different RPC calls defined. The
<code>ServerEventStream</code> is the main communication channel from
the plugin to the clients. When a client connects, he has to initiate
this stream in order to receive any events. The
<code>ClientEventCall</code> and <code>ClientParamCall</code> are unary
calls for the client, which means that they are invoked once per
message. Since QtGrpc initially only provided unary calls and server
streaming, we had to utilize the available functionality, which is by
far not optimal for this usecase. Ideally, in the future this service
definition should support bidirectional streams and client side streams,
since an long-lived communication channel through a stream is always
faster then using unary calls. A client implementation can now implement
this basic service and would then be able to communicate with the
server.</p>
<h2 id="qtgrpc-client-implementation">3.3 QtGrpc Client
Implementation</h2>
<h1 id="chapter-5-conclusions">Chapter 5: Conclusions</h1>
<h2 id="experimental-results">Experimental Results</h2>
<h3 id="integrity">Integrity</h3>
<h3 id="performance-1">Performance</h3>
<h2 id="future-work">Future Work</h2>
<h2 id="acknowledgements">Acknowledgements</h2>
<h1 class="unnumbered" label="bibliography"
id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-applecoreaudio" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div
class="csl-right-inline">Apple: Audio unit v3 plug-ins, <a
href="https://developer.apple.com/documentation/audiotoolbox/audio_unit_properties">https://developer.apple.com/documentation/audiotoolbox/audio_unit_properties</a>,
last accessed 2023/10/23.</div>
</div>
<div id="ref-audiolatency" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div
class="csl-right-inline">Joseph Timoney, R.V., Victor Lazzarini:
Approaches for constant audio latency on android, <a
href="https://mural.maynoothuniversity.ie/6664/">https://mural.maynoothuniversity.ie/6664/</a>,
last accessed 2023/11/14.</div>
</div>
<div id="ref-protobufcasestudy" class="csl-entry" role="listitem">
<div class="csl-left-margin">3. </div><div
class="csl-right-inline">Lakhani", "Maharaja: Protocol buffers: An
overview (case study in c++). (2014).</div>
</div>
<div id="ref-performanceprotobufIoT" class="csl-entry" role="listitem">
<div class="csl-left-margin">4. </div><div
class="csl-right-inline">Popić &amp; Bojan Mrazovac &amp; Dražen Pezer
&amp; Nikola Teslić", "Srđan: Performance evaluation of using protocol
buffers in the internet of things communication. (2016).</div>
</div>
<div id="ref-rtaudio" class="csl-entry" role="listitem">
<div class="csl-left-margin">5. </div><div
class="csl-right-inline">Scavone, G.P.: RtAudio: A cross-platform c++
class for realtime audio input/output, <a
href="https://ccrma.stanford.edu/~gary/papers/icmc2002c.pdf">https://ccrma.stanford.edu/~gary/papers/icmc2002c.pdf</a>,
last accessed 2023/11/14.</div>
</div>
<div id="ref-cppn2074" class="csl-entry" role="listitem">
<div class="csl-left-margin">6. </div><div
class="csl-right-inline">Vandevoorde, D.: Plugins in c++, <a
href="https://www.open-std.org/JTC1/sc22/wg21/docs/papers/2006/n2074.pdf">https://www.open-std.org/JTC1/sc22/wg21/docs/papers/2006/n2074.pdf</a>,
last accessed 2023/07/23.</div>
</div>
</div>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>User Interface<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Dynamic Shared Object<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Inspired by: <a
href="https://www.youtube.com/watch?v=5uIsadq-nyk">NppNow 2023, What is
Low Latency C++? (Part 2) - Timur Doumler</a><a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Taken from: <a
href="https://www.youtube.com/watch?v=Q0vrQFyAdWI">ADC 2019, Fabian
Renn-Giles &amp; Dave Rowland - Real-time 101</a><a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>First In First Out<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Software Development Kit<a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Digital Audio Workstation<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Midi Polyphonic Expression<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Inter Process Communication<a href="#fnref9"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Introduced in proposal: <a
href="https://github.com/grpc/proposal/blob/master/L67-cpp-callback-api.md">L67-cpppcallback-api</a><a
href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>User Datagram Protocol<a href="#fnref11"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Low-frequency oscillators<a href="#fnref12"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
