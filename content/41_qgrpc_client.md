## 4.3 Implementing the QtGrpc Client

This segment explores the use of QtGrpc to develop a client implementation for
the `ClapInterface` service, as previously outlined in the [server API
section](#server_api). The central aim of the client library is to aid in the
development of graphical user interfaces for audio plugins. This tool leverages
the CLAP-RCI library to allow for creating plugins, by focusing on the UI
aspect. It efficiently handles the event stream emitted by the audio plugin and
incorporates these events into Qt's event loop. This strategic integration
pursues to utilize Qt's established signals and slots mechanism, empowering
graphic components to autonomously and effectively manage their visual
representation. The library's design and functionality are particularly geared
towards simplifying and enhancing the GUI development process, while the
creation of example plugins serves as an additional use case.

Currently, the development of this library is concentrated on integrating with
Qt's QML and QtQuick modules. It's important to note that while the term
"library" is used, the implementation is more akin to an extended sandbox
designed for experimental purposes in implementing these features.

### 4.3.1 Core Concepts of the Client Library

The project's build configuration includes CLAP-RCI as a dependency. It employs
the `api.proto` file to generate the necessary C++ client code. The
implementation is divided into two primary sections:

1. **Clap.Interface:** This part functions in the background, handling the
   transmission of events to and from the server. It forms the core of the
   library, integrating the incoming messages with Qt.

2. **Clap.Controls:** This section is dedicated to the actual UI
   components, which are Qml components pre-set with essential properties and
   signals. These components are designed to effectively manage and display the
   events received from the server.

In the CMake configuration file, the server library is added as a dependency.
The client code is generated by leveraging QtGrpc's protobuf plugin:

```cmake
# src/CMakeLists.txt
add_subdirectory(3rdparty/clap-remote)
set(proto_file "${CMAKE_CURRENT_SOURCE_DIR}/3rdparty/clap-remote/api/v0/api.proto")
add_subdirectory(clapinterface)

~~~

# src/clapinterface/CMakeLists.txt
# Generate the protobuf and grpc files
qt_add_protobuf(ClapMessages QML
    QML_URI "Clap.Messages"
    PROTO_FILES ${proto_file}
)

qt_add_grpc(ClapMessages CLIENT
    PROTO_FILES ${proto_file}
)
```

The `qt_add_protobuf` and `qt_add_grpc` functions in CMake, provided by QtGrpc,
streamline the process of integrating with the `protoc` plugin. These functions
are specifically designed to simplify the generation of client code from
protobuf definitions. Optionally, they can be configured to create QML
metadata, enhancing the integration of protobuf messages within QML code. This
feature allows client applications to seamlessly incorporate the generated
modules into both their C++ and QML codebases, thereby facilitating a more
efficient and cohesive development process.

We define the *QML module* for integration into both C++ and QML codebases of
client applications as follows:

```cmake
add_library(ClapInterface STATIC)
qt_add_qml_module(ClapInterface
    URI "Clap.Interface"
    VERSION ${CMAKE_PROJECT_VERSION}
    CLASS_NAME ClapInterfacePlugin
    PLUGIN_TARGET clapinterfaceplugin
    SOURCES
        "qclapinterface.h"
        "qclapinterface.cpp"
        "qnotehandler.h"
        "qnotehandler.cpp"
        "qnote.h"
        "qnote.cpp"
    OUTPUT_DIRECTORY ${QML_OUTPUT_DIR_INTERFACE}
    IMPORTS Clap.Messages
)
```

This configuration results in the creation of the `Clap.Interface` module,
which is later registered with the QML engine. By declaring the `ClapInterface`
as a static library, we minimize the number of dependencies on shared
libraries. The compilation of this module produces the following files:

```bash
❯ tree -L 2 cmake-build/Clap/
Clap/
└── Interface
    ├── ClapInterface_qml_module_dir_map.qrc
    ├── ClapInterface.qmltypes
    ├── libclapinterfaceplugin.a
    └── qmldir
```

For their applications, users of this library need to link against the
`libclapinterfaceplugin.a` file. This approach ensures that when the
`Clap.Interface` module is imported in QML code, the QML engine will load the
relevant directory. With this setup in place, the next step is to explore the
functionalities and features of the `QClapInterface` class.

```cpp
// src/clapinterface/qclapinterface.h
~~~
#include "api.qpb.h"
#include "api_client.grpc.qpb.h"
using namespace api::v0;
~~~
```

The code begins by including the generated protobuf and grpc files. These files
are crucial for every QtGrpc client implementation as they provide a
Qt-compatible representation of the server's proto API.

```cpp
// src/clapinterface/qclapinterface.h
~~~
class QClapInterface : public QObject
{
    Q_OBJECT
    QML_SINGLETON
    QML_NAMED_ELEMENT(ClapInterface)
    QML_UNCREATABLE("QClapInterface is a singleton")

    Q_PROPERTY(PluginState state READ state NOTIFY stateChanged)
    Q_PROPERTY(bool visible READ visible WRITE setVisible NOTIFY visibleChanged)
    Q_PROPERTY(QWindow* transientParent READ transientParent NOTIFY transientParentChanged)
~~~
```

The `QClapInterface` class is uniquely identified as a `QML_SINGLETON`,
ensuring only one instance exists within the QML engine. This singleton design
is used as it centralizes the handling of all incoming and outgoing
messages, eliminating the need for multiple instances. The class incorporates
several properties using the `Q_PROPERTY` macro, which facilitates their
accessibility from QML code. These properties are crucial for basic UI
functionalities, such as toggling the UI's visibility or setting the parent
window as per host requests.

To initiate communication with the server, the library requires the creation of
a `QGrpcChannel`. This process is encapsulated in the `connect` function and is
an essential step for users of this library to engage in server interactions.

```cpp
// src/clapinterface/qclapinterface.cpp
void QClapInterface::connect(const QString &url, const QString &hash)
{
    // Provide the metadata to the server
    QGrpcChannelOptions channelOptions(url);
    metadata = {
        { QByteArray(Metadata::PluginHashId.data()), { hash.toUtf8() } },
    };
    channelOptions.withMetadata(metadata);

    // Create a Http2 channel for the communication
    auto channel = std::make_shared<QGrpcHttp2Channel>(channelOptions);
    client->attachChannel(channel);
    // Start the server side stream
    stream = client->streamServerEventStream(ClientRequest(), {});
    ~~~
}
```

This function is critical for establishing a connection between the client and
the server. It is initiated by passing the `url` and `hash` arguments,
typically supplied by CLAP-RCI during the executable's startup. These arguments
are crucial in invoking this function. The `hash` is added to the channel,
allowing the server to identify the specific plugin instance that the client
aims to connect with. The `client` in this context utilizes the generated
QtGrpc code to interact with the server-defined service. This setup ensures to
establish a communication between the client application and the server.

The `client` object is declared as a unique pointer to the
`ClapInterface::Client` type:

```cpp
    // src/clapinterface/qclapinterface.h
    std::unique_ptr<ClapInterface::Client> client = {};
```

Delving into the generated code, we find that the `Client` class accurately
mirrors the service defined by the server:

```cpp
// build/api_client.grpc.qpb.h
class QPB_CLAPMESSAGES_EXPORT Client : public QAbstractGrpcClient
{
    Q_OBJECT
public:
    explicit Client(QObject *parent = nullptr);
    std::shared_ptr<QGrpcServerStream> streamServerEventStream(~~~);

    QGrpcStatus ClientEventCall(~~~);
    Q_INVOKABLE void ClientEventCall(~~~);

    QGrpcStatus ClientParamCall(~~~);
    Q_INVOKABLE void ClientParamCall(~~~);
~~~
```

The code above showcases the three service calls defined in the server's API. The
generated code integrates seamlessly into Qt's ecosystem, utilizing the
`Q_INVOKABLE` macro, which allows these methods to be invoked from QML. All
other generated messages are also integrated into Qt's meta-object-system for
convenience, enabling easy utilization and integration of these messages. This
approach facilitates the incorporation of the external gRPC system, potentially
written in any language supported by gRPC, into Qt's framework.

To complete the `connect` function, it's necessary to establish a connection to
the server stream and manage the incoming messages effectively.

```cpp
// src/clapinterface/qclapinterface.cpp
// void QClapInterface::connect(~~~) {
~~~
    QObject::connect(stream.get(), &QGrpcServerStream::errorOccurred, this,
        [](const QGrpcStatus &status) { QGuiApplication::quit(); }
    );

    QObject::connect(stream.get(), &QGrpcServerStream::finished, this,
         []() { QGuiApplication::quit(); }
    );

    QObject::connect(stream.get(), &QGrpcServerStream::messageReceived, this,
        [this]() { processEvents(stream->read<ServerEvents>()); }
    );
    callbackTimer.start();
~~~
```

In the current setup, both the `errorOccurred` and `finished` signals from the
stream are simply connected to trigger the application's termination. The key
aspect of this function, however, is the handling of incoming messages in the
`processEvents` callback. This callback is responsible for distributing the
received events as needed.

The function also initializes the `callbackTimer`, which operates at a fixed
frequency. This design choice mirrors the approach used in CLAP-RCI and serves
to consolidate all outgoing events into a single message. The rationale behind
this method is to minimize the number of unary calls to the server, thereby
enhancing performance. Ideally, future implementations would benefit from the
use of bidirectional streaming to further reduce the number of independent RPC
calls. This would offer a more efficient communication channel between the
client and the server.

```cpp
// src/clapinterface/qclapinterface.cpp
void QClapInterface::processEvents(const ServerEvents &events)
{
    for (const auto &event : events.events()) {
        switch (event.event()) {

            case EventGadget::PluginActivate: {
                mState = Active;
                emit stateChanged();
            } break;
            { ~~~ }
            case EventGadget::GuiCreate: {
                // Verify successful creation back to the host.
                auto call = client->ClientEventCall(create(EventGadget::GuiCreate));
                mState = Connected;
                emit stateChanged();
            } break;
            { ~~~ }
            case EventGadget::GuiShow: {
                client->ClientEventCall(create(EventGadget::GuiShow));
                setVisible(true);
            } break;
            { ~~~ }
        }
    }
}
```

The `processEvents` function is triggered every time a new message is received
from the server. It iterates over all the events within the received message,
handling each event based on its type, as defined in the mentioned `enum` of
the API. The function utilizes a switch statement to process different events,
such as `PluginActivate`, `GuiCreate`, and `GuiShow`. For each case,
appropriate actions are taken, such as updating the state of the plugin or
modifying visibility, and corresponding signals are emitted. These signals then
enable subscribed components within the application to respond to these events
effectively.

```cpp
// src/clapinterface/qclapinterface.cpp
~~~
            case EventGadget::Note: {
                if (!event.hasNote())
                    return;
                emit noteReceived(event.note());
            } break;
~~~
```

When the `Note` event occurs, the function first checks if the event contains a
note using the `hasNote()` method. If a note is present, the `noteReceived`
signal is emitted with the note's information. This signal's emission triggers
all QML components that are subscribed to the `noteReceived` signal.
Consequently, these components receive notification of the event and can
respond accordingly.

### 4.3.2 QML Components in the Client Library

This section focuses on the custom QML components included in the library.
These components are designed to quickly construct user interfaces that
dynamically respond to server-sent events. For instance, the `ClapWindow.qml`
component enables the application window to automatically respond to events
like `GuiShow`, `GuiHide`, and `GuiSetTransient`. This component essentially
extends the functionality of Qt's native `ApplicationWindow` QML type. A
snippet of its implementation is as follows:

```qml
// src/clapcontrols/ClapWindow.qml

import QtQuick
import QtQuick.Controls.Basic

import Clap.Interface
import Clap.Controls

ApplicationWindow {
    id: ctrl
    ~~~
    Connections {
        target: ClapInterface
        function onVisibleChanged() {
            ctrl.visible = ClapInterface.visible;
        }
        function onTransientParentChanged() {
            ctrl.transientParent = ClapInterface.transientParent;
        }
        function onStateChanged() {
            ctrl.pluginActive = QClapInterface.state == QClapInterface.Active;
        }
    }
    ~~~
}
```

In `ClapWindow.qml`, the `ClapInterface` is utilized to control the window's
visibility, parent, and state in response to received events. The `Connections`
block is set up to monitor changes in `ClapInterface`'s properties such as
visibility and transient parent. As these properties change, corresponding
functions within the `Connections` block update the `ApplicationWindow`
accordingly. This setup ensures that the UI accurately reflects the current
state and responses of the underlying plugin logic.

The component is straightforward to use in applications. By importing
`Clap.Controls`, users can easily implement `ClapWindow` in their QML code:

```qml
import Clap.Controls

ClapWindow {
    id: root
    title: "My CLAP GUI!"
    width: 640; height: 480
}
```

This simple implementation is sufficient for a basic plugin where the window's
visibility and behavior are managed by the host application.

The `Dial` component is an essential element in audio plugins, serving as a
core interaction facility. It quickly responds to parameter-related events from
the host, enabling automation and user interaction with the plugin's
parameters. The component's design allows users to customize its visual
representation to suit their specific needs. The functionality of `ClapDial`
demonstrates the library's ability to seamlessly integrate UI components with
the data received from their corresponding audio plugin. This integration
ensures a synchronized relationship between user actions and the plugin's
responses, highlighting the effectiveness in maintaining dynamic interaction
within audio plugins.

In the `ClapDial` QML component, connectivity to the `ClapInterface` singleton
is established to act on incoming signals:

```qml
// src/clapcontrols/ClapDial.qml
import Clap.Interface
import Clap.Controls

Dial {
    id: ctrl
    Connections {
        target: ClapInterface
        function onParamChanged() {
            ctrl.param = ClapInterface.param(paramId);
            ctrl.value = ctrl.param.value;
            ctrl.modulation = ctrl.param.modulation;
        }
        function onParamInfoChanged() {
            ctrl.paramInfo = ClapInterface.paramInfo(paramId);
            ctrl.value = ctrl.paramInfo.defaultValue;
            ctrl.from = ctrl.paramInfo.minValue;
            ctrl.to = ctrl.paramInfo.maxValue;
        }
~~~
    onValueChanged: {
        if (ctrl.pressed || ctrl.hovered) {
            ClapInterface.enqueueParam(ctrl.paramId, ctrl.value);
        }
    }
~~~
```

The component listens for the `onParamChanged` signal, which is emitted in
response to updates from the host application. Upon receiving this signal,
`ClapDial` updates its properties to reflect these changes. QML's robust
property system ensures that these updates are seamlessly managed through
bindings.

For interactions, such as a value change in the dial, the component checks
whether it is currently pressed or hovered over. This check helps determine if
the user is actively interacting with the dial. When an interaction is
detected, the updated value is enqueued to be sent to the server-library. This
process ensures that the updates are incorporated into the audio-processing
section of the plugin.

This approach effectively abstracts the communication process, allowing users
of the client library to focus primarily on the UI's visualization. It aligns
with standard practices in other Qt-application development. Users are not
burdened with the intricacies of server communication but have the option to
engage with these events if they choose.This design enhances user experience by
providing a robust default setup, which users can opt to customize according to
their preferences. It streamlines the process of integrating interactive UI
components while ensuring efficient communication with the server.

### 4.3.3 Example Plugins: Implementing a Gain Plugin

This final section demonstrates the practical application of the previously
discussed libraries in constructing a simple audio plugin. A perfect example
for this demonstration is a **Gain** plugin. The basic implementation of such a
plugin was briefly touched upon in the [clap-section](#creating_a_clap_plugin),
where we utilized the `clap` library for a rudimentary setup. This initial
implementation, while covering the basics, lacked a user interface (UI), which
is typically quite labor-intensive to develop without external libraries.

Below is the build file for the Gain plugin, illustrating how the proposed
libraries are integrated into its construction:

```cmake
cmake_minimum_required(VERSION 3.2)

project(QtClapPlugins
    VERSION 0.0.1
    LANGUAGES CXX
)

include(../cmake/autolink_clap.cmake)

set(target ${PROJECT_NAME})
add_library(${target} SHARED
    clap_entry.cpp
    reveal/revealprocessor.h
    reveal/revealprocessor.cpp
    gain/gainprocessor.cpp
    gain/gainprocessor.h
)

target_link_libraries(${target} PRIVATE clap-remote)
create_symlink_target_clap(${target})

# Add GUIs
add_subdirectory(reveal/gui)
add_subdirectory(gain/gui)
```

After setting up the project and including the `autolink_clap.cmake` script,
the Gain plugin's build configuration is established. This script simplifies
the process by automatically creating symlinks for the CLAP library and
renaming the generated shared library to comply with CLAP specifications.

Essential to this setup is the `clap_entry.cpp` file, which includes the
necessary CLAP entry point `clap_entry` and the `clap_plugin_factory`
implementation.

The Gain plugin, along with another plugin called `Reveal`, is part of this
CLAP suite. Both plugins are directly integrated into the plugin layer,
handling the processing callback. The build file then specifies subdirectories
for their GUIs, which are standalone executables capable of operating
independently or in conjunction with the host application. When connected to
the server, these GUIs respond to the incoming events.

The `Gain` class, derived from `CorePlugin`, is structured as follows:

```cpp
#ifndef GAINPROCESSOR_H
#define GAINPROCESSOR_H

#include <plugin/coreplugin.h>

class Gain final : public CorePlugin
{
public:
    Gain(const std::string &pluginPath, const clap_host *host);
    static const clap_plugin_descriptor *descriptor();

private:
    bool init() noexcept override;
    void defineAudioPorts() noexcept;

private:
    uint32_t mChannelCount = 1;
};

#endif // GAINPROCESSOR_H
```

In this declaration, the `init` and `defineAudioPorts` methods are overridden,
and a member variable for tracking the audio channel count is defined. The
constructor passes necessary details to the `CorePlugin` base class:

```cpp
Gain::Gain(const std::string &pluginPath, const clap_host *host)
    : CorePlugin(Settings(pluginPath).withPluginDirExecutablePath("Gain"),
        descriptor(), host, std::make_unique<GainModule>(*this))
{}
```

In the Gain plugin, a `Settings` object is instantiated to specify the path to
the plugin's executable. If this path points to a valid executable, the base
class activates the GUI feature. The plugin also passes its descriptor and the
host details to the `CorePlugin` base class. Additionally, the root module for
the plugin, `GainModule`, is created, focusing on the processing aspect.

The modular approach in the plugin separates processing logic from the plugin
layer. This separation, though not the primary focus during the library's
development, facilitates a more organized structure. The primary emphasis was
on establishing smooth communication. The `GainModule`, responsible for the
plugin's processing, also defines parameters for host exposure:

```cpp
// The GainModule controls all the processing of the plugin.
class GainModule final : public Module
{
public:
    explicit GainModule(Gain &plugin) : Module(plugin, "GainModule", 0)
    {}

    void init() noexcept override
    {
        mParamGain = addParameter(
            0, "gain",
            CLAP_PARAM_IS_AUTOMATABLE | CLAP_PARAM_IS_MODULATABLE | CLAP_PARAM_REQUIRES_PROCESS,
            std::make_unique<DecibelValueType>(-40.0, 40.0, 0)
        );
    }

    clap_process_status process(const clap_process *process, uint32_t frame) noexcept override
    { /* Same as the 'mini_gain' example */ }

private:
    Parameter *mParamGain = nullptr;
};
```

In this implementation, the `gain` parameter is defined and made available to
the host. The process callback's details, similar to those in the
[mini_gain](#processing) example, are omitted for brevity. This setup provides
a fundamental yet functional plugin structure that can be used in host
applications.

The GUI for this plugin is developed as a separate project. The build
configuration for the GUI project is detailed below, showcasing the modular
nature of the development process. This structure not only simplifies the
creation of plugins but also ensures that each component, whether DSP or UI,
can be developed and maintained independently.

In the build file for the Gain plugin's GUI component, the setup is similar to
that of regular Qt applications:

```cmake
find_package(Qt6 REQUIRED COMPONENTS Core Qml Quick)
qt_standard_project_setup(REQUIRES 6.5)

set(target Gain)
qt_add_executable(${target} main.cpp)

set_target_properties(${target}
    PROPERTIES
        WIN32_EXECUTABLE TRUE
        MACOSX_BUNDLE TRUE
)

qt_add_qml_module(${target}
    URI "GainModule"
    VERSION 1.0
    QML_FILES "Main.qml"
)

target_link_libraries(${target}
    PRIVATE
        Qt6::Quick
        clapinterfaceplugin
        ClapControls
)

create_symlink_target_gui(${target})
```

Here the necessary Qt modules are first searched. The project then declares a
regular (qt) executable, with the unique aspect of linking against the
`clapinterfaceplugin` and `ClapControls` libraries. The primary entry point for
the Gain plugin's GUI is defined in the `main.cpp` file:

```cpp
int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);
    QQmlApplicationEngine engine;
    engine.loadFromModule("GainModule", "Main");
    if (engine.rootObjects().isEmpty())
        return -1;
```

In this segment, a `QGuiApplication` object is instantiated, and the
`QQmlApplicationEngine` is set up to load the primary QML file from the
"GainModule". This structure is typical of Qt applications, where the Qt event
loop is enabled by default, given that the application runs as a separate
process.

The next part of the `main` function introduces specific functionalities for
the plugin:

```cpp
    QCommandLineParser parser;
    parser.process(app);
    const auto args = parser.positionalArguments();
    if (args.length() == 2) {
        auto *interface = engine.singletonInstance<QClapInterface*>("Clap.Interface","ClapInterface");
        if (interface == nullptr) {
            qFatal() << "Unable to find ClapInterface instance";
            return -1;
        }
        interface->connect(args[0], args[1]);
    }
    return QGuiApplication::exec(); // Start the event loop.
```

In this section, a `QCommandLineParser` is used to process the arguments passed
to the application. The expectation is that these arguments will include the
`url` and the `hash` of the plugin. If the arguments are provided, the GUI
connects to the server via the `QClapInterface`. This connection initializes
the interaction between the GUI and the server. Finally the event loop is
started.

The final piece of the implementation is the `Main.qml` file, which leverages
the custom components developed for interaction with the server and host
application. This setup illustrates a complete, functional plugin GUI,
integrated into a standard Qt application framework, yet tailored to meet the
specific demands of the CLAP standard.

```qml
~~~
import Clap.Controls

ClapWindow {
    id: root
    title: "QGain"
    width: 640; height: 480

    ColumnLayout {
        anchors.fill: parent
        anchors.margins: 10
        spacing: 10

        Text { ~~~ }
        ClapDial {
            id: dial
            paramId: 0
            Layout.alignment: Qt.AlignHCenter | Qt.AlignVCenter
            Layout.preferredHeight: parent.width / 3
            Layout.preferredWidth: parent.width / 3
        }
        Image { ~~~ }
    }
}
```

The Gain plugin UI starts with a `ClapWindow` that organizes its components in
a `ColumnLayout`. This layout features a text label, a `ClapDial` with the
parameter ID `0`, corresponding to the GainModule's parameter, and an image.
The interface is straightforward but fully equipped for communication with host
applications.

Upon completion, both the QGain and QReveal plugins are tested in Bitwig
Studio, a professional digital audio workstation (DAW).

![QGain Plugin Hosted](images/qtclapplugins_gain.png){#fig:qgain}

*@fig:qgain* illustrates the QGain plugin in operation within Bitwig Studio.
The plugin's user interface, centered around an interactive dial, effectively
synchronizes with the audio processor. Changes made via the UI are reflected in
the processor's values and vice versa, ensuring a cohesive link between the
plugin's interface and its audio processing functionality. Managed by the
`ClapWindow` component, the UI is seamlessly integrated into Bitwig Studio,
providing responsiveness as requested by the host.

![QReveal Plugin Hosted](images/qtclapplugins_reveal.png){#fig:qreveal}

*@fig:qreveal* depicts the QReveal plugin operating in Bitwig Studio. This
plugin specializes in monitoring MIDI notes. It actively visualizes these notes
along with relevant metadata, providing a dynamic and informative view of the
MIDI activity on the track.
