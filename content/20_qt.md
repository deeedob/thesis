# Chapter 2: The Qt Framework

## Introduction

[Qt](https://www.qt.io/) stands as a widely-recognized framework designed to
facilitate the creation of cross-platform graphical user interfaces (GUIs). Its
distinctiveness lies in its ability to function seamlessly across diverse
platforms such as Linux, Windows, macOS, Android, and even embedded systems. A
remarkable feature of Qt is that it achieves this cross-functionality with
minimal modifications to its core codebase.

Emerging in 1992 from the innovation labs of Trolltech, a Norwegian software
enterprise, Qt's journey has seen several pivotal moments. A notable one was
its acquisition by Nokia in 2008. Today, the baton of its active maintenance
and further development is in the hands of 'The Qt Company'.

Delving into its licensing, Qt presents two clear routes. The first aligns with
the open-source ethos through the GNU (L)GPL license, underscoring a
community-driven spirit. This path demands adherence to terms embedded
within the license. On the other hand, for developers with an inclination
towards building proprietary or commercial software without open-sourcing
constraints, Qt offers a commercial license.

While its foundation is deeply rooted in C++, Qt showcases adaptability by
providing language bindings, exemplified by [Qt for Python /
PySide6](https://doc.qt.io/qtforpython-6/). This augmentation not only speeds
up the development process but also capitalizes on the robustness of utilizing
the power of the already present C++ modules by re-using them.

Within the vast expanse of the Qt universe, developers are presented with two
primary paradigms for GUI crafting: Widgets and QML. Widgets offer the
traditional approach in creating UI elements, making it the go-to for many
classical desktop applications Their imprint is evident in widely-adopted
applications
like
[Telegram](https://github.com/telegramdesktop/tdesktop/blob/dev/Telegram/SourceFiles/mainwidget.cpp#L255)
and [Google
Earth](https://github.com/google/earthenterprise/blob/893f6b470673e2bad4cacdd8eec5ad1f179b6249/earth_enterprise/src/fusion/fusionui/main.cpp#L28).

Conversely, **QML** (Qt Modeling Language) represents a contemporary,
declarative approach to UI design. It employs a clear, JSON-like syntax, while
utilizing inline JavaScript for imperative operations. Central to its design
philosophy is dynamic object interconnection, leaning heavily on property
bindings. One of its notable strengths is the seamless integration with C++,
ensuring a clean separation between application logic and view, without any
significant performance trade-offs.

Above the foundational QML module resides **QtQuick**, the de facto standard
library for crafting QML applications. While [Qt
QML](https://doc.qt.io/qt-6/qtqml-index.html) lays down the essential
groundwork by offering the QML and JavaScript engines, overseeing the core
mechanics, QtQuick comes equipped with fundamental types imperative for
spawning user interfaces in QML. This library furnishes the visual canvas and
encompasses a suite of types tailored for creating and animating visual
entities.

A significant distinction between Widgets and QML lies in their rendering
methodologies. Widgets, relying on software rendering, primarily lean on the
CPU for graphical undertakings. This sometimes prevents them from harnessing
the full graphical capabilities of a device. QML, however, pivots this paradigm
by capitalizing on the hardware GPU, ensuring a more vibrant and efficient
rendering experience. Its declarative nature streamlines design interpretation
and animation implementation, ultimately enhancing the development velocity.

**Qt6**, the most recent landmark release in the Qt series, heralded a plethora
of advancements. A standout among these is the QRHI (Qt Rendering Hardware
Interface). Functioning subtly in the background, QRHI adeptly handles the
complexities associated with graphic hardware. Its primary mission? To
guarantee unwavering performance consistency across a diverse range of graphic
backends. The introduction of [QRHI](https://doc.qt.io/qt-6/qrhi.html)
underscores Qt's steadfast dedication to fortifying its robust cross-platform
capabilities, aiming to create a unified experience across various graphic
backends.

![Qt Rendering Hardware Interface [RHI](https://doc.qt.io/qt-6/topics-graphics.html)](images/qt_rhi.png)

*Figure 8* delineates the architecture of the prevailing rendering interface.
At the foundational layer, we find the native graphic APIs, encompassing the
likes of OpenGL, Vulkan, Metal, and Direct 3D 11. Positioned just above is the
QWindows implementation, which is housed within the QtGui module of Qt.
Notably, QtWidgets occupies a niche between these two levels. Given that
Widgets emerged before the QRhi module, their integration with QRhi isn't as
profound. While certain widgets do offer OpenGL capabilities, their primary
reliance is on the [QPainter](https://doc.qt.io/qt-6/qpainter.html#drawing)
API. Ascending to the subsequent tier, we are greeted by the Qt Rendering
Hardware Interface, which serves as a crucial bridge, offering an abstraction
layer over hardware-accelerated graphics APIs.

> **Note:** As of this writing, QRHI maintains a limited compatibility
> assurance, implying potential shifts in its API. However, such changes are
> anticipated to be minimal.

To integrate QRHI within personal projects, one needs to link against
`Qt::GuiPrivate` followed by an inclusion directive, `#include <rhi/qrhi.h>`.
Navigating higher up the abstraction ladder, we encounter the QtQuick and
QtQuick3D modules, standing as testament to Qt's evolutionary journey in
graphics rendering.

## 2.2 QtGrpc

[QtGrpc](https://doc.qt.io/qt-6/qtgrpc-index.html) is a relatively new module
that is, at the time of writing at version Qt 6.6, currently in technical preview.
It builds upon [gRPC](https://github.com/grpc/grpc), a cross-platform high performance
**R**emote **P**rocedural **C**all (RPC) framework, that generates client/server bindings
for many supported languages:

![gRPC supported [languages](https://grpc.io/docs/languages/)](images/grpc_langs.png)

- Explain briefly, protobuf API, Server, Clients, API, streams and calls.
- Performance of native grpc.

## 2.3 Solving the Problem (Qt-Side)

- Approaches for integration
    - Picking up the event loop (only windows and mac) because of glib and event loop
        - unstable, launching in seperate thread.
    - Remote GUIs, launching executable
    - Using QtGrpc as a foundation

- Goal from Qt side (cross platform, easy development, integration into event loop).

